Index: app/src/main/java/com/bailout/stickk/ubi4/utility/SprGestureItemsProvider.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.bailout.stickk.ubi4.utility\r\n\r\nimport android.content.Context\r\nimport com.bailout.stickk.R\r\nimport com.bailout.stickk.ubi4.models.SprGestureItem\r\n\r\nclass SprGestureItemsProvider {\r\n\r\n    fun getSprGestureItemList(context: Context): ArrayList<SprGestureItem> {\r\n        val sprGestureItemList: ArrayList<SprGestureItem> = ArrayList()\r\n        sprGestureItemList.add(\r\n            SprGestureItem(\r\n                context.getString(R.string.thumb_finger), R.drawable.grip_the_ball, false\r\n            )\r\n        )\r\n        sprGestureItemList.add(\r\n            SprGestureItem(\r\n                context.getString(R.string.palm_closing), R.drawable.koza, false\r\n            )\r\n        )\r\n        sprGestureItemList.add(\r\n            SprGestureItem(\r\n                context.getString(R.string.palm_opening), R.drawable.grip_the_ball, false\r\n            )\r\n        )\r\n        sprGestureItemList.add(\r\n            SprGestureItem(\r\n                context.getString(R.string.ok_pinch), R.drawable.ok, false\r\n            )\r\n        )\r\n        sprGestureItemList.add(\r\n            SprGestureItem(\r\n                context.getString(R.string.flexion), R.drawable.koza, false\r\n            )\r\n        )\r\n        sprGestureItemList.add(\r\n            SprGestureItem(\r\n                context.getString(R.string.extension), R.drawable.grip_the_ball, false\r\n            )\r\n        )\r\n        sprGestureItemList.add(\r\n            SprGestureItem(\r\n                context.getString(R.string.gesture_key), R.drawable.kulak, false\r\n            )\r\n        )\r\n        sprGestureItemList.add(\r\n            SprGestureItem(\r\n                context.getString(R.string.pistol_pointer_gesture), R.drawable.ok, false\r\n            )\r\n        )\r\n        sprGestureItemList.add(\r\n            SprGestureItem(\r\n                context.getString(R.string.adduction), R.drawable.grip_the_ball, false\r\n            )\r\n        )\r\n        sprGestureItemList.add(\r\n            SprGestureItem(\r\n                context.getString(R.string.abduction), R.drawable.koza, false\r\n            )\r\n        )\r\n        sprGestureItemList.add(\r\n            SprGestureItem(\r\n                context.getString(R.string.pronation), R.drawable.kulak, false\r\n            )\r\n        )\r\n        sprGestureItemList.add(\r\n            SprGestureItem(\r\n                context.getString(R.string.supination), R.drawable.grip_the_ball, false\r\n            )\r\n        )\r\n        return sprGestureItemList\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/bailout/stickk/ubi4/utility/SprGestureItemsProvider.kt b/app/src/main/java/com/bailout/stickk/ubi4/utility/SprGestureItemsProvider.kt
--- a/app/src/main/java/com/bailout/stickk/ubi4/utility/SprGestureItemsProvider.kt	(revision 2e86270d31f9f3c3a5c83efb1c8c55f93434d15e)
+++ b/app/src/main/java/com/bailout/stickk/ubi4/utility/SprGestureItemsProvider.kt	(date 1733741488839)
@@ -6,36 +6,24 @@
 
 class SprGestureItemsProvider {
 
+    fun getAnimationIdByKeyNameGesture(keyNameGesture: String) : Int{
+
+    }
+
     fun getSprGestureItemList(context: Context): ArrayList<SprGestureItem> {
         val sprGestureItemList: ArrayList<SprGestureItem> = ArrayList()
         sprGestureItemList.add(
             SprGestureItem(
-                context.getString(R.string.thumb_finger), R.drawable.grip_the_ball, false
-            )
-        )
-        sprGestureItemList.add(
-            SprGestureItem(
-                context.getString(R.string.palm_closing), R.drawable.koza, false
-            )
-        )
-        sprGestureItemList.add(
-            SprGestureItem(
-                context.getString(R.string.palm_opening), R.drawable.grip_the_ball, false
-            )
-        )
-        sprGestureItemList.add(
-            SprGestureItem(
-                context.getString(R.string.ok_pinch), R.drawable.ok, false
-            )
-        )
-        sprGestureItemList.add(
-            SprGestureItem(
-                context.getString(R.string.flexion), R.drawable.koza, false
+                context.getString(R.string.thumb_finger), R.drawable.grip_the_ball, false, keyNameGesture = "ThumbFingers"
             )
         )
+        sprGestureItemList.add(SprGestureItem(context.getString(R.string.palm_closing), R.drawable.koza, false, "Close"))
+        sprGestureItemList.add(SprGestureItem(context.getString(R.string.palm_opening), R.drawable.grip_the_ball, false, "Open"))
+        sprGestureItemList.add(SprGestureItem(context.getString(R.string.ok_pinch), R.drawable.ok, false, "Pinch"))
+        sprGestureItemList.add(SprGestureItem(context.getString(R.string.flexion), R.drawable.koza, false, "Wrist_Flex"))
         sprGestureItemList.add(
             SprGestureItem(
-                context.getString(R.string.extension), R.drawable.grip_the_ball, false
+                context.getString(R.string.extension), R.drawable.grip_the_ball, false, ""
             )
         )
         sprGestureItemList.add(
Index: app/src/main/java/com/bailout/stickk/ubi4/ui/fragments/SprGestureFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import android.annotation.SuppressLint\r\nimport android.app.Dialog\r\nimport android.content.Intent\r\nimport android.graphics.Color\r\nimport android.graphics.drawable.ColorDrawable\r\nimport android.os.Bundle\r\nimport android.os.Handler\r\nimport android.util.Log\r\nimport android.view.LayoutInflater\r\nimport android.view.View\r\nimport android.view.ViewGroup\r\nimport android.widget.TextView\r\nimport android.widget.Toast\r\nimport androidx.fragment.app.Fragment\r\nimport androidx.lifecycle.lifecycleScope\r\nimport androidx.recyclerview.widget.LinearLayoutManager\r\nimport androidx.recyclerview.widget.RecyclerView\r\nimport com.bailout.stickk.R\r\nimport com.bailout.stickk.databinding.Ubi4FragmentSprGesturesBinding\r\nimport com.bailout.stickk.new_electronic_by_Rodeon.persistence.preference.PreferenceKeys\r\nimport com.bailout.stickk.ubi4.adapters.dialog.GesturesCheckAdapter\r\nimport com.bailout.stickk.ubi4.adapters.dialog.OnCheckGestureListener\r\nimport com.bailout.stickk.ubi4.adapters.widgetDelegeteAdapters.GesturesOpticDelegateAdapter\r\nimport com.bailout.stickk.ubi4.adapters.widgetDelegeteAdapters.OneButtonDelegateAdapter\r\nimport com.bailout.stickk.ubi4.adapters.widgetDelegeteAdapters.PlotDelegateAdapter\r\nimport com.bailout.stickk.ubi4.ble.BLECommands\r\nimport com.bailout.stickk.ubi4.ble.SampleGattAttributes.MAIN_CHANNEL\r\nimport com.bailout.stickk.ubi4.ble.SampleGattAttributes.WRITE\r\nimport com.bailout.stickk.ubi4.contract.navigator\r\nimport com.bailout.stickk.ubi4.contract.transmitter\r\nimport com.bailout.stickk.ubi4.data.DataFactory\r\nimport com.bailout.stickk.ubi4.data.local.CollectionGesturesProvider\r\nimport com.bailout.stickk.ubi4.models.BindingGestureItem\r\nimport com.bailout.stickk.ubi4.models.DialogCollectionGestureItem\r\nimport com.bailout.stickk.ubi4.models.SprGestureItem\r\nimport com.bailout.stickk.ubi4.persistence.preference.PreferenceKeysUBI4\r\nimport com.bailout.stickk.ubi4.persistence.preference.PreferenceKeysUBI4.DEVICE_ID_IN_SYSTEM_UBI4\r\nimport com.bailout.stickk.ubi4.persistence.preference.PreferenceKeysUBI4.GESTURE_ID_IN_SYSTEM_UBI4\r\nimport com.bailout.stickk.ubi4.persistence.preference.PreferenceKeysUBI4.PARAMETER_ID_IN_SYSTEM_UBI4\r\nimport com.bailout.stickk.ubi4.ui.gripper.with_encoders.UBI4GripperScreenWithEncodersActivity\r\nimport com.bailout.stickk.ubi4.ui.main.MainActivityUBI4\r\nimport com.bailout.stickk.ubi4.ui.main.MainActivityUBI4.Companion.graphThreadFlag\r\nimport com.bailout.stickk.ubi4.ui.main.MainActivityUBI4.Companion.listWidgets\r\nimport com.bailout.stickk.ubi4.ui.main.MainActivityUBI4.Companion.updateFlow\r\nimport com.livermor.delegateadapter.delegate.CompositeDelegateAdapter\r\nimport com.simform.refresh.SSPullToRefreshLayout\r\nimport kotlinx.coroutines.DelicateCoroutinesApi\r\nimport kotlinx.coroutines.Dispatchers.Default\r\nimport kotlinx.coroutines.Dispatchers.Main\r\nimport kotlinx.coroutines.launch\r\nimport kotlinx.coroutines.withContext\r\n\r\n@Suppress(\"DEPRECATION\")\r\nclass SprGestureFragment() : Fragment() {\r\n    private lateinit var binding: Ubi4FragmentSprGesturesBinding\r\n    private var main: MainActivityUBI4? = null\r\n    private var mDataFactory: DataFactory = DataFactory()\r\n\r\n    private val selectedGesturesSet = mutableSetOf<String>()\r\n\r\n    private var gestureNameList =  ArrayList<String>()\r\n    private var onDestroyParent: (() -> Unit)? = null\r\n    private var onDestroyParentCallbacks = mutableListOf<() -> Unit>()\r\n\r\n\r\n    @SuppressLint(\"CutPasteId\")\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater,\r\n        container: ViewGroup?,\r\n        savedInstanceState: Bundle?\r\n    ): View {\r\n        binding = Ubi4FragmentSprGesturesBinding.inflate(inflater, container, false)\r\n        if (activity != null) {\r\n            main = activity as MainActivityUBI4?\r\n        }\r\n        loadGestureNameList()\r\n        //настоящие виджеты\r\n        widgetListUpdater()\r\n        //фейковые виджеты\r\n//        adapterWidgets.swapData(mDataFactory.fakeData())\r\n\r\n\r\n        binding.refreshLayout.setLottieAnimation(\"loader_3.json\")\r\n        binding.refreshLayout.setRepeatMode(SSPullToRefreshLayout.RepeatMode.REPEAT)\r\n        binding.refreshLayout.setRepeatCount(SSPullToRefreshLayout.RepeatCount.INFINITE)\r\n        binding.refreshLayout.setOnRefreshListener { refreshWidgetsList() }\r\n\r\n\r\n        binding.sprGesturesRv.layoutManager = LinearLayoutManager(context)\r\n        binding.sprGesturesRv.adapter = adapterWidgets\r\n        return binding.root\r\n    }\r\n\r\n    private fun refreshWidgetsList() {\r\n        graphThreadFlag = false\r\n        listWidgets.clear()\r\n        onDestroyParentCallbacks.forEach { it.invoke() }\r\n        onDestroyParentCallbacks.clear()\r\n        transmitter().bleCommand(BLECommands.requestInicializeInformation(), MAIN_CHANNEL, WRITE)\r\n        //TODO только для демонстрации\r\n        Handler().postDelayed({\r\n            binding.refreshLayout.setRefreshing(false)\r\n        }, 1000)\r\n    }\r\n\r\n\r\n    @OptIn(DelicateCoroutinesApi::class)\r\n    fun widgetListUpdater() {\r\n        viewLifecycleOwner.lifecycleScope.launch(Main) {\r\n            withContext(Default) {\r\n                updateFlow.collect { value ->\r\n                    main?.runOnUiThread {\r\n                        Log.d(\"widgetListUpdater\",\"${mDataFactory.prepareData(0)}\")\r\n                        adapterWidgets.swapData(mDataFactory.prepareData(0))\r\n                        binding.refreshLayout.setRefreshing(false)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private val adapterWidgets = CompositeDelegateAdapter(\r\n        PlotDelegateAdapter(\r\n            plotIsReadyToData = { num -> System.err.println(\"plotIsReadyToData $num\") },\r\n            onDestroyParent = { onDestroyParent -> onDestroyParentCallbacks.add(onDestroyParent)}\r\n\r\n        ),\r\n\r\n        OneButtonDelegateAdapter(\r\n            onButtonPressed = { addressDevice, parameterID, command ->\r\n                oneButtonPressed(\r\n                    addressDevice,\r\n                    parameterID,\r\n                    command\r\n                )\r\n            },\r\n            onButtonReleased = { addressDevice, parameterID, command ->\r\n                oneButtonReleased(\r\n                    addressDevice,\r\n                    parameterID,\r\n                    command\r\n                )\r\n            },\r\n            onDestroyParent = { onDestroyParent -> onDestroyParentCallbacks.add(onDestroyParent)}\r\n\r\n        ),\r\n        GesturesOpticDelegateAdapter(\r\n            gestureNameList = gestureNameList,\r\n            onSelectorClick = {},\r\n            onAddGesturesToSprScreen = { onSaveClickDialog, listSprItem, bindingGestureList ->\r\n                showControlGesturesDialog(onSaveClickDialog, listSprItem, bindingGestureList)\r\n            },\r\n            onShowGestureSettings = { deviceAddress, parameterID, gestureID -> showGestureSettings(deviceAddress, parameterID, gestureID) },\r\n            onRequestGestureSettings = {deviceAddress, parameterID, gestureID -> requestGestureSettings(deviceAddress, parameterID, gestureID)},\r\n            onSetCustomGesture = { onSaveDotsClick, position, name ->\r\n                showCustomGesturesDialog(onSaveDotsClick, position, name)\r\n            },\r\n            onDestroyParent = { onDestroyParent -> this.onDestroyParent = onDestroyParent},\r\n        ),\r\n    )\r\n\r\n    private fun requestGestureSettings(deviceAddress: Int, parameterID: Int, gestureID: Int) {\r\n        Log.d(\"requestGestureSettings\", \"считывание данных в фрагменте\")\r\n        transmitter().bleCommand(BLECommands.requestGestureInfo(deviceAddress, parameterID, gestureID), MAIN_CHANNEL, WRITE)\r\n    }\r\n    private fun showGestureSettings (deviceAddress: Int, parameterID: Int, gestureID: Int) {\r\n        val intent = Intent(context, UBI4GripperScreenWithEncodersActivity::class.java)\r\n        intent.putExtra(DEVICE_ID_IN_SYSTEM_UBI4, deviceAddress)\r\n        intent.putExtra(PARAMETER_ID_IN_SYSTEM_UBI4, parameterID)\r\n        intent.putExtra(GESTURE_ID_IN_SYSTEM_UBI4, gestureID)\r\n        startActivity(intent)\r\n    }\r\n\r\n    @SuppressLint(\"MissingInflatedId\", \"LogNotTimber\")\r\n    private fun showCustomGesturesDialog(\r\n        onSaveClick: ((name: String, position: Int) -> Unit),\r\n        position: Int,\r\n        name: String\r\n    ) {\r\n        System.err.println(\"showAddGestureToSprScreen\")\r\n        val dialogBinding =\r\n            layoutInflater.inflate(R.layout.ubi4_dialog_gestures_add_to_spr_screen, null)\r\n        val myDialog = Dialog(requireContext())\r\n        val gesturesRv = dialogBinding.findViewById<RecyclerView>(R.id.dialogAddGesturesRv)\r\n        val linearLayoutManager = LinearLayoutManager(context)\r\n        myDialog.setContentView(dialogBinding)\r\n        myDialog.setCancelable(false)\r\n        myDialog.window!!.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))\r\n        myDialog.show()\r\n        val titleText = dialogBinding.findViewById<TextView>(R.id.dialogTitleBindingTv)\r\n        titleText.setText(R.string.assign_gesture)\r\n\r\n//        val gestureItemsProvider = GestureSprAndCustomItemsProvider()\r\n//        val sprGestureItemList =\r\n//            gestureItemsProvider.getSprAndCustomGestureItemList(requireContext())\r\n        val sprGestureItemList: ArrayList<DialogCollectionGestureItem> =\r\n            ArrayList(CollectionGesturesProvider.getCollectionGestures().map { DialogCollectionGestureItem(it) })\r\n\r\n        sprGestureItemList.forEach { dialogGesture ->\r\n            if (dialogGesture.gesture.gestureName == name) {\r\n                dialogGesture.check = true\r\n            }\r\n        }\r\n\r\n\r\n        var selectedGesturePosition = sprGestureItemList.indexOfFirst { it.check }\r\n        Log.d(\"selectedGesturesSet\", \"Selected gesture: $selectedGesturePosition\")\r\n\r\n\r\n        linearLayoutManager.orientation = LinearLayoutManager.VERTICAL\r\n        gesturesRv.layoutManager = linearLayoutManager\r\n        val adapter = GesturesCheckAdapter(sprGestureItemList, object :\r\n            OnCheckGestureListener {\r\n            override fun onGestureClicked(clickedPosition: Int, dialogGesture: DialogCollectionGestureItem) {\r\n\r\n                if (selectedGesturePosition != -1 && selectedGesturePosition == clickedPosition) {\r\n                    sprGestureItemList[selectedGesturePosition] =\r\n                        sprGestureItemList[selectedGesturePosition].copy(check = false)\r\n                    selectedGesturePosition = -1\r\n                    gesturesRv.adapter?.notifyItemChanged(clickedPosition)\r\n\r\n                    selectedGesturesSet.remove(dialogGesture.gesture.gestureName)\r\n                    Log.d(\"showCustomGesturesDialog1\", \" remove1: $selectedGesturesSet\")\r\n\r\n                    return\r\n                }\r\n\r\n                if (selectedGesturesSet.contains(dialogGesture.gesture.gestureName) && selectedGesturePosition != clickedPosition) {\r\n                    Toast.makeText(\r\n                        context,\r\n                        getString(R.string.toast_notification_gesture_in_use),\r\n                        Toast.LENGTH_SHORT\r\n                    ).show()\r\n                    Log.d(\"selectedGesturesSet\", \"$selectedGesturesSet\")\r\n                    return\r\n                }\r\n\r\n                if (selectedGesturePosition != -1) {\r\n                    sprGestureItemList[selectedGesturePosition] =\r\n                        sprGestureItemList[selectedGesturePosition].copy(check = false)\r\n                    selectedGesturesSet.remove(sprGestureItemList[selectedGesturePosition].gesture.gestureName)\r\n                    Log.d(\"showCustomGesturesDialog1\", \" remove2: $selectedGesturesSet\")\r\n\r\n                    gesturesRv.adapter?.notifyItemChanged(selectedGesturePosition)\r\n                }\r\n\r\n                selectedGesturePosition = clickedPosition\r\n                sprGestureItemList[clickedPosition] =\r\n                    sprGestureItemList[clickedPosition].copy(check = true)\r\n                gesturesRv.adapter?.notifyItemChanged(clickedPosition)\r\n\r\n            }\r\n        })\r\n        gesturesRv.adapter = adapter\r\n\r\n        val cancelBtn = dialogBinding.findViewById<View>(R.id.dialogAddGesturesToCancelBtn)\r\n        cancelBtn.setOnClickListener {\r\n            myDialog.dismiss()\r\n        }\r\n\r\n        val saveBtn = dialogBinding.findViewById<View>(R.id.dialogAddGesturesToSaveBtn)\r\n        saveBtn.setOnClickListener {\r\n            val selectedGesture = if (selectedGesturePosition != -1) {\r\n                sprGestureItemList[selectedGesturePosition].gesture.gestureName\r\n            } else {\r\n                null\r\n            }\r\n\r\n            if (selectedGesture != null) {\r\n                selectedGesturesSet.add(selectedGesture)\r\n                Log.d(\"showCustomGesturesDialog1\", \" add: $selectedGesturesSet\")\r\n            } else {\r\n\r\n                name.let {\r\n                    selectedGesturesSet.remove(it)\r\n                    Log.d(\"showCustomGesturesDialog1\", \" remove3: $selectedGesturesSet\")\r\n\r\n                }\r\n\r\n            }\r\n            myDialog.dismiss()\r\n            onSaveClick.invoke(selectedGesture ?: \"\", position)\r\n\r\n\r\n        }\r\n    }\r\n\r\n\r\n    @SuppressLint(\"MissingInflatedId\", \"LogNotTimber\", \"CutPasteId\")\r\n    private fun showControlGesturesDialog(\r\n        onSaveClick: (List<SprGestureItem>) -> Unit,\r\n        selectedGestures: List<SprGestureItem>,\r\n        bindingGestureList: List<BindingGestureItem>\r\n    ) {\r\n        System.err.println(\"showAddGestureToSprScreen\")\r\n        val dialogBinding =\r\n            layoutInflater.inflate(R.layout.ubi4_dialog_gestures_add_to_spr_screen, null)\r\n        val myDialog = Dialog(requireContext())\r\n        val gesturesRv = dialogBinding.findViewById<RecyclerView>(R.id.dialogAddGesturesRv)\r\n\r\n\r\n        val linearLayoutManager = LinearLayoutManager(context)\r\n        myDialog.setContentView(dialogBinding)\r\n        myDialog.setCancelable(false)\r\n        myDialog.window!!.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))\r\n        myDialog.show()\r\n\r\n\r\n\r\n        val sprGestureItemList: ArrayList<DialogCollectionGestureItem> =\r\n            ArrayList(CollectionGesturesProvider.getCollectionGestures().map { DialogCollectionGestureItem(it) })\r\n\r\n\r\n\r\n        for (dialogGesture in sprGestureItemList) {\r\n            selectedGestures.find { it.title == dialogGesture.gesture.gestureName }?.let {\r\n                dialogGesture.check = true\r\n            }\r\n        }\r\n        Log.d(\"showControlGesturesDialog\", \"$sprGestureItemList\")\r\n\r\n        linearLayoutManager.orientation = LinearLayoutManager.VERTICAL\r\n        gesturesRv.layoutManager = linearLayoutManager\r\n        val adapter = GesturesCheckAdapter(sprGestureItemList, object :\r\n            OnCheckGestureListener {\r\n            override fun onGestureClicked(position: Int, dialogGesture: DialogCollectionGestureItem) {\r\n                System.err.println(\"onGestureClicked $position\")\r\n                Log.d(\"onGestureClicked\", \"$sprGestureItemList\")\r\n\r\n                val checkedItems = sprGestureItemList.mapIndexedNotNull { index, item ->\r\n                    if (item.check) index else null\r\n                }\r\n                var unselectedPosition =\r\n                    bindingGestureList.indexOfFirst { it.sprGestureItem.title == dialogGesture.gesture.gestureName }\r\n                sprGestureItemList[position] =\r\n                    sprGestureItemList[position].copy(check = !sprGestureItemList[position].check)\r\n\r\n\r\n\r\n                if (!sprGestureItemList[position].check) {\r\n                    unselectedPosition = checkedItems.indexOf(position)\r\n                    Log.d(\r\n                        \"GestureUnselected\",\r\n                        \"Position of unselected gesture: $unselectedPosition\"\r\n                    )\r\n                }\r\n\r\n                // Удаление безопасным способом\r\n                if (unselectedPosition >= 0 && unselectedPosition < bindingGestureList.size) {\r\n                    val iterator = selectedGesturesSet.iterator()\r\n                    while (iterator.hasNext()) {\r\n                        val gesture = iterator.next()\r\n                        if (gesture == bindingGestureList[unselectedPosition].nameOfUserGesture) {\r\n                            iterator.remove()\r\n                        }\r\n                    }\r\n                } else {\r\n                    Log.e(\r\n                        \"onGestureClicked1\",\r\n                        \"Index $unselectedPosition is out of bounds for bindingGestureList with size ${bindingGestureList.size}\"\r\n                    )\r\n                }\r\n\r\n                Log.d(\"onGestureClicked\", \"$sprGestureItemList\")\r\n                gesturesRv.adapter?.notifyItemChanged(position)\r\n            }\r\n        })\r\n        gesturesRv.adapter = adapter\r\n\r\n\r\n        val cancelBtn = dialogBinding.findViewById<View>(R.id.dialogAddGesturesToCancelBtn)\r\n        cancelBtn.setOnClickListener {\r\n            myDialog.dismiss()\r\n        }\r\n\r\n        val saveBtn = dialogBinding.findViewById<View>(R.id.dialogAddGesturesToSaveBtn)\r\n        saveBtn.setOnClickListener {\r\n            val selectedGestures = sprGestureItemList.filter { it.check }.map { gestureItem ->\r\n                SprGestureItem(gestureItem.gesture.gestureName, gestureItem.gesture.gestureImage, true)\r\n            }\r\n\r\n\r\n\r\n            myDialog.dismiss()\r\n            onSaveClick.invoke(selectedGestures)\r\n            Log.d(\"showControlGesturesDialog\", \"$selectedGestures\")\r\n            Log.d(\"showControlGesturesDialog\", \"$selectedGesturesSet\")\r\n\r\n        }\r\n    }\r\n\r\n    private fun oneButtonPressed(addressDevice: Int, parameterID: Int, command: Int) {\r\n        System.err.println(\"oneButtonPressed    parameterID: $parameterID   command: $command\")\r\n        transmitter().bleCommand(\r\n            BLECommands.sendOneButtonCommand(addressDevice,parameterID, command),\r\n            MAIN_CHANNEL,\r\n            WRITE\r\n        )\r\n    }\r\n\r\n    private fun oneButtonReleased(addressDevice: Int, parameterID: Int, command: Int) {\r\n\r\n\r\n\r\n        transmitter().bleCommand(\r\n            BLECommands.sendOneButtonCommand(addressDevice,parameterID, command),\r\n            MAIN_CHANNEL,\r\n            WRITE\r\n        )\r\n    }\r\n    private fun loadGestureNameList() {\r\n        val macKey = navigator().getString(PreferenceKeysUBI4.LAST_CONNECTION_MAC)\r\n        gestureNameList.clear()\r\n        for (i in 0 until PreferenceKeysUBI4.NUM_GESTURES) {\r\n            System.err.println(\"loadGestureNameList: \" + PreferenceKeysUBI4.SELECT_GESTURE_SETTINGS_NUM + macKey + i)\r\n            gestureNameList.add(\r\n                navigator().getString(PreferenceKeysUBI4.SELECT_GESTURE_SETTINGS_NUM + macKey + i).toString()\r\n            )\r\n//            System.err.println(\"loadGestureNameList: ${gestureNameList[i]}\")\r\n        }\r\n    }\r\n\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        onDestroyParentCallbacks.forEach { it.invoke() }\r\n\r\n\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/bailout/stickk/ubi4/ui/fragments/SprGestureFragment.kt b/app/src/main/java/com/bailout/stickk/ubi4/ui/fragments/SprGestureFragment.kt
--- a/app/src/main/java/com/bailout/stickk/ubi4/ui/fragments/SprGestureFragment.kt	(revision 2e86270d31f9f3c3a5c83efb1c8c55f93434d15e)
+++ b/app/src/main/java/com/bailout/stickk/ubi4/ui/fragments/SprGestureFragment.kt	(date 1733738584551)
@@ -375,8 +375,9 @@
 
         val saveBtn = dialogBinding.findViewById<View>(R.id.dialogAddGesturesToSaveBtn)
         saveBtn.setOnClickListener {
+            //TODO не создавать элемент SPRGestureItem, а брать его из SPRGestureItemProvider
             val selectedGestures = sprGestureItemList.filter { it.check }.map { gestureItem ->
-                SprGestureItem(gestureItem.gesture.gestureName, gestureItem.gesture.gestureImage, true)
+                SprGestureItem(gestureItem.gesture.gestureName, gestureItem.gesture.gestureImage, check = true, "")
             }
 
 
Index: app/src/main/java/com/bailout/stickk/ubi4/ui/fragments/MotionTrainingFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.bailout.stickk.ubi4.ui.fragments\r\n\r\nimport android.annotation.SuppressLint\r\nimport android.app.Dialog\r\nimport android.graphics.Color\r\nimport android.graphics.drawable.ColorDrawable\r\nimport android.os.Bundle\r\nimport android.os.CountDownTimer\r\nimport android.os.SystemClock\r\nimport android.util.Log\r\nimport android.view.LayoutInflater\r\nimport android.view.View\r\nimport android.view.ViewGroup\r\nimport android.widget.Chronometer\r\nimport androidx.fragment.app.Fragment\r\nimport com.bailout.stickk.R\r\nimport com.bailout.stickk.databinding.Ubi4FragmentMotionTrainingBinding\r\nimport com.bailout.stickk.ubi4.ble.ParameterProvider\r\nimport com.bailout.stickk.ubi4.data.local.OpticTrainingStruct\r\nimport com.bailout.stickk.ubi4.data.parser.BLEParser\r\nimport com.bailout.stickk.ubi4.models.ConfigOMGDataCollection\r\nimport com.bailout.stickk.ubi4.models.GestureConfig\r\nimport com.bailout.stickk.ubi4.models.GesturePhase\r\nimport com.bailout.stickk.ubi4.models.GesturesId\r\nimport com.bailout.stickk.ubi4.models.SprGestureItem\r\nimport com.bailout.stickk.ubi4.rx.RxUpdateMainEventUbi4\r\nimport com.bailout.stickk.ubi4.ui.main.MainActivityUBI4.Companion.main\r\nimport com.google.gson.Gson\r\nimport com.google.gson.reflect.TypeToken\r\nimport io.reactivex.disposables.CompositeDisposable\r\nimport io.reactivex.schedulers.Schedulers\r\nimport kotlinx.serialization.json.Json\r\nimport java.io.File\r\nimport java.io.IOException\r\n\r\nclass MotionTrainingFragment(\r\n    val onFinishTraining: () -> Unit,\r\n) : Fragment() {\r\n\r\n    private var _bindig: Ubi4FragmentMotionTrainingBinding? = null\r\n    private val binding get() = _bindig!!\r\n\r\n    private val countDownTime = 0L\r\n    private val interval = 30L\r\n    private val pauseBeforeStart = 100L\r\n    private lateinit var sprGestureItemList: ArrayList<SprGestureItem>\r\n    var currentGestureIndex = 0\r\n    private var timer: CountDownTimer? = null\r\n    private var preparationTimer: CountDownTimer? = null\r\n    private var isCountingDown = false\r\n    private lateinit var learningTimer: Chronometer\r\n    private lateinit var learningStepTimer: Chronometer\r\n    private var loggingFilename = \"serial_data\"\r\n    private val disposables = CompositeDisposable()\r\n    private val rxUpdateMainEvent = RxUpdateMainEventUbi4.getInstance()\r\n    private val gestures: MutableList<Map<String, String>> = mutableListOf()\r\n    private var prot = 0\r\n    private var startLineInLearningTable = 0\r\n    private var dataCollection: Map<String, Any> = mapOf()\r\n    private lateinit var gestureConfig: GestureConfig\r\n\r\n    private var generalTime: Long = 0\r\n    private var nCycles: Int = 0\r\n    private var gestureSequence: List<String> = emptyList()\r\n    private var gestureNumber: Int = 0\r\n    private var preGestDuration: Double = 0.0\r\n    private var atGestDuration: Double = 0.0\r\n    private var postGestDuration: Double = 0.0\r\n    private var gestureDuration: Int = 0\r\n    private var gesturesId: GesturesId? = null\r\n    private var gestureIndex = -1\r\n    private var baselineDuration: Double = 0.0\r\n\r\n    private var currentGestureId: Int = 0\r\n\r\n\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n//    private fun buildGesturePhases(\r\n//        baselineDuration: Double,\r\n//        preDuration: Double,\r\n//        atDuration: Double,\r\n//        postDuration: Double,\r\n//        gestureSequence: List<String>,\r\n////        gestureIdMap: Map<String, Int>\r\n//    ): List<GesturePhase> {\r\n//\r\n//        if (gestureSequence.isEmpty()) return emptyList()\r\n//\r\n//        val phases = mutableListOf<GesturePhase>()\r\n//\r\n//        val baselinePhase = PhaseBaseline(timeGesture = baselineDuration)\r\n//        phases.add(baselinePhase)\r\n//\r\n//        val firstGesture = gestureSequence.first()\r\n////        val firstGestureId = gestureIdMap[firstGesture] ?: run {\r\n////            return emptyList()\r\n////        }\r\n//\r\n////        // Pre фаза для первого жеста (после Baseline)\r\n////        phases.add(PhasePre(timeGesture = 5, gestureName = firstGesture, gestureId = firstGestureId))\r\n////\r\n////        // At фаза для первого жеста\r\n////        phases.add(PhaseAt(timeGesture = atDuration.toInt(), gestureName = firstGesture, gestureId = firstGestureId))\r\n//\r\n//        for (i in 1 until gestureSequence.size) {\r\n//            val gestureName = gestureSequence[i]\r\n////            val gestureId = gestureIdMap[gestureName]?: run {\r\n////                // Если нет id для жеста - показ Toast:\r\n////                // Возвращаемся или пропускаем жест\r\n////                return emptyList()\r\n////            }\r\n//\r\n//            // Так как у нас после первого жеста идет Post предыдущего + Pre следующего = 4с\r\n//            // Но мы можем разбить на две фазы:\r\n//            // Сначала Post фаза предыдущего жеста (от gestureSequence[i-1])\r\n//            val prevGestureName = gestureSequence[i - 1]\r\n////            val prevGestureId = gestureIdMap[prevGestureName]?.toInt() ?: -1\r\n//\r\n////            phases.add(PhasePost(timeGesture = postDuration.toInt(), gestureName = prevGestureName, gestureId = prevGestureId))\r\n//\r\n////            // Затем Pre фаза для текущего жеста\r\n////            phases.add(PhasePre(\r\n////                timeGesture = preDuration.toInt(),\r\n////                gestureName = gestureName,\r\n////                gestureId = gestureId\r\n////            ))\r\n////\r\n////            // И теперь At фаза для текущего жеста\r\n////            phases.add(PhaseAt(\r\n////                timeGesture = atDuration.toInt(),\r\n////                gestureName = gestureName,\r\n////                gestureId = gestureId\r\n////            ))\r\n//        }\r\n//\r\n//        return phases\r\n//\r\n//\r\n//    }\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    @SuppressLint(\"CheckResult\", \"DefaultLocale\")\r\n    override fun onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n        Log.d(\"LagSpr\", \"Motion onCreate\")\r\n        //loadGestureConfig()\r\n        val result = trainingDataProcessing()\r\n        result.forEach { Log.d(\"trainingDataProcessing\", \"trainingDataProcessing ${it}\") }\r\n\r\n        val mBLEParser = main.let { BLEParser(it) }\r\n        //фейковые данные принимаемого потока\r\n//        android.os.Handler().postDelayed({\r\n//            mBLEParser?.parseReceivedData(BLECommands.testDataTransfer())\r\n//        }, 1000)\r\n//        Handler().postDelayed({\r\n//            mBLEParser?.parseReceivedData(BLECommands.testDataTransfer())\r\n\r\n\r\n        val parameter = ParameterProvider.getParameter(10, 5)\r\n        Log.d(\"TestOptic\", \"OpticTrainingStruct = ${parameter.parameterDataSize}\")\r\n        val opticStreamDisposable = rxUpdateMainEvent.uiOpticTrainingObservable\r\n            .subscribeOn(Schedulers.io())\r\n            .observeOn(Schedulers.io())\r\n            .subscribe { dataCode ->\r\n                try {\r\n                    val dataStringRaw = parameter.data\r\n                    if (dataStringRaw.isBlank() || dataStringRaw == \"None\") {\r\n                        Log.e(\"TestFileContain\", \"Data is empty or invalid\")\r\n                        return@subscribe\r\n                    }\r\n\r\n                    val opticTrainingStruct =\r\n                        Json.decodeFromString<OpticTrainingStruct>(\"\\\"${parameter.data}\\\"\")\r\n                    val dataString = opticTrainingStruct.data.joinToString(separator = \" \") {\r\n                        String.format(\"%.1f\", it)\r\n                    }\r\n                    Log.d(\"TestFileContain\", \"OpticTrainingStruct = $dataString\")\r\n                    Log.d(\"TestFileContain\", \"Number Frame = ${opticTrainingStruct.numberOfFrame}\")\r\n\r\n                    writeToFile(dataString)\r\n                } catch (e: Exception) {\r\n                    Log.e(\"TestOptic\", \"Error decoding data: ${e.message}\")\r\n                }\r\n            }\r\n        disposables.add(opticStreamDisposable)\r\n    }\r\n\r\n    override fun onCreateView(\r\n        inflater: LayoutInflater,\r\n        container: ViewGroup?,\r\n        savedInstanceState: Bundle?\r\n    ): View? {\r\n        Log.d(\"LagSpr\", \"Motion onCreateView\")\r\n\r\n        _bindig = Ubi4FragmentMotionTrainingBinding.inflate(inflater, container, false)\r\n        return binding.root\r\n\r\n    }\r\n\r\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\r\n        Log.d(\"LagSpr\", \"Motion onViewCreated\")\r\n        super.onViewCreated(view, savedInstanceState)\r\n        binding.stopTrainingBtn.setOnClickListener {\r\n            showConfirmCancelTrainingDialog {\r\n                parentFragmentManager.beginTransaction().replace(\r\n                    R.id.fragmentContainer, SprTrainingFragment()\r\n                ).commit()\r\n            }\r\n        }\r\n\r\n\r\n//        val gestureItemsProvider = SprGestureItemsProvider()\r\n//        sprGestureItemList = gestureItemsProvider.getSprGestureItemList(requireContext())\r\n//        startPreparationCountDown()\r\n\r\n//        learningPreprocessingParse()\r\n    }\r\n\r\n\r\n//    private fun loadGestureConfig() {\r\n//        dataCollection = Gson().fromJson(\r\n//            requireContext().assets.open(\"config.json\").reader(),\r\n//            object : TypeToken<Map<String, Any>>() {}.type\r\n//        )\r\n//        Log.d(\"GestureUpdate\", \"dataCollection = $dataCollection \")\r\n//\r\n//\r\n//\r\n//        learningTimer = Chronometer(requireContext())\r\n//        learningStepTimer = Chronometer(requireContext())\r\n//        generalTime = (SystemClock.elapsedRealtime() - learningTimer.base) / 1000\r\n//        nCycles = dataCollection[\"N_CYCLES\"].toString().toDouble().toInt()\r\n//        val gestureSequence =\r\n//            (dataCollection[\"GESTURE_SEQUENCE\"] to ArrayList<String>()).first as List<String>\r\n//        gestureNumber = (gestureSequence as ArrayList<*>).size - 1\r\n//        preGestDuration = dataCollection[\"PRE_GEST_DURATION\"].toString().toDouble()\r\n//        atGestDuration = dataCollection[\"AT_GEST_DURATION\"].toString().toDouble()\r\n//        postGestDuration = dataCollection[\"POST_GEST_DURATION\"].toString().toDouble()\r\n//        gestureDuration = (preGestDuration + atGestDuration + postGestDuration).toInt()\r\n//        gesturesId = dataCollection[\"GESTURES_ID\"]\r\n//        baselineDuration = dataCollection[\"BASELINE_DURATION\"].toString().toDouble()\r\n//\r\n//        // Извлекаем последовательность жестов из JSON (массив строк)\r\n////        val gestureSequenceJson = jsonObject.getJSONArray(\"GESTURE_SEQUENCE\")\r\n////        val gestureSequence =\r\n////            mutableListOf<String>() // Список для хранения последовательности жестов\r\n////        for (i in 0 until gestureSequenceJson.length()) {\r\n////            // Добавляем каждый жест из массива JSON в список\r\n////            gestureSequence.add(gestureSequenceJson.getString(i))\r\n////        }\r\n//\r\n//        // Извлекаем идентификаторы жестов из JSON (объект с парами \"жест - ID\")\r\n////        val gesturesIdJson = jsonObject.getJSONObject(\"GESTURES_ID\")\r\n////        val gesturesId = mutableMapOf<String, Int>()//Словарь для хранения идентификаторов жестов\r\n////        val keys = gesturesIdJson.keys()\r\n////        while (keys.hasNext()) {\r\n////            val key = keys.next()\r\n////            gesturesId[key] = gesturesIdJson.getInt(key)\r\n////        }\r\n//\r\n//        gestureConfig = GestureConfig(\r\n//            baselineDuration = baselineDuration,\r\n//            preGestDuration = preGestDuration,\r\n//            atGestDuration = atGestDuration,\r\n//            postGestDuration = postGestDuration,\r\n//            gestureSequence = gestureSequence,\r\n////            gesturesId = gesturesId\r\n//        )\r\n//        Log.d(\"GestureUpdate\", \"Gesture Config: $gestureConfig\")\r\n//\r\n////        val phases = buildGesturePhases(\r\n////            baselineDuration = baselineDuration,\r\n////            preDuration = preGestDuration,\r\n////            atDuration = atGestDuration,\r\n////            postDuration = postGestDuration,\r\n////            gestureSequence = gestureSequence,\r\n//////            gestureIdMap = gesturesId,\r\n////        )\r\n//        val phases = trainingDataProcessing()\r\n//        phases.forEach {\r\n//            //   Log.d(\"GestureUpdate\", \"Phases: ${it.value}\")\r\n//        }\r\n//\r\n//\r\n//    }\r\n\r\n\r\n    // Метод для обновления UI с текущим жестом\r\n    private fun updateGestures(gestureName: String) {\r\n        try {\r\n            val gestureImageResId = getGestureImageResource(gestureName)\r\n            binding.motionHandIv.setImageResource(gestureImageResId)\r\n            binding.motionNameOfGesturesTv.text = gestureName\r\n            Log.d(\"GestureUpdate\", \"Gesture updated: $gestureName\")\r\n        } catch (e: Exception) {\r\n            Log.e(\"GestureError\", \"Failed to update gesture: ${e.message}\")\r\n        }\r\n    }\r\n\r\n    private fun getGestureImageResource(gestureName: String): Int {\r\n        return when (gestureName) {\r\n            \"ThumbFingers\" -> R.drawable.grip_the_ball\r\n            \"Close\" -> R.drawable.koza\r\n            \"Open\" -> R.drawable.ok\r\n            \"Neutral\" -> R.drawable.ok\r\n            \"Pinch\" -> R.drawable.kulak\r\n            \"Indication\" -> R.drawable.koza\r\n            \"Wrist_Flex\" -> R.drawable.grip_the_ball\r\n            \"Wrist_Extend\" -> R.drawable.kulak\r\n            else -> R.drawable.grip_the_ball\r\n        }\r\n    }\r\n\r\n    @SuppressLint(\"MissingInflatedId\")\r\n    fun showConfirmCompletedTrainingDialog(confirmClick: () -> Unit) {\r\n        stopTimers()\r\n        preparationTimer?.cancel()\r\n        val dialogBinding =\r\n            layoutInflater.inflate(R.layout.ubi4_dialog_confirm_finish_training, null)\r\n        val myDialog = Dialog(requireContext())\r\n        myDialog.setContentView(dialogBinding)\r\n        myDialog.setCancelable(false)\r\n        myDialog.window!!.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))\r\n        myDialog.show()\r\n\r\n        val confirmBtn = dialogBinding.findViewById<View>(R.id.ubi4CompletedTrainingBtn)\r\n        confirmBtn.setOnClickListener {\r\n            myDialog.dismiss()\r\n            confirmClick()\r\n            onFinishTraining()\r\n        }\r\n    }\r\n\r\n    @SuppressLint(\"MissingInflatedId\")\r\n    fun showConfirmCancelTrainingDialog(confirmClick: () -> Unit) {\r\n        stopTimers()\r\n        preparationTimer?.cancel()\r\n        val dialogBinding =\r\n            layoutInflater.inflate(R.layout.ubi4_dialog_cancel_training, null)\r\n        val myDialog = Dialog(requireContext())\r\n        myDialog.setContentView(dialogBinding)\r\n        myDialog.setCancelable(false)\r\n        myDialog.window!!.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))\r\n        myDialog.show()\r\n\r\n        val confirmBtn = dialogBinding.findViewById<View>(R.id.ubi4DialogConfirmCancelTrainingBtn)\r\n        confirmBtn.setOnClickListener {\r\n            stopTimers()\r\n            myDialog.dismiss()\r\n            confirmClick()\r\n        }\r\n        val cancelBtn = dialogBinding.findViewById<View>(R.id.ubi4DialogCancelTrainingCancelBtn)\r\n        cancelBtn.setOnClickListener {\r\n            myDialog.dismiss()\r\n            resumeTimers()\r\n        }\r\n\r\n    }\r\n\r\n    private fun stopTimers() {\r\n        timer?.cancel()\r\n        preparationTimer?.cancel()\r\n    }\r\n\r\n    private fun resumeTimers() {\r\n        if (isCountingDown) {\r\n            //startCountdown()\r\n        } else {\r\n            //startPreparationCountDown()\r\n        }\r\n    }\r\n\r\n    private fun writeToFile(data: String, isAppend: Boolean = true) {\r\n        Log.i(\"FileInfo\", \"WriteFile Start\")\r\n\r\n        try {\r\n            learningTimer.base = SystemClock.elapsedRealtime()\r\n            learningTimer.start()\r\n            val path = requireContext().getExternalFilesDir(null)\r\n            val file = File(path, loggingFilename)\r\n            val curData = trainingDataProcessing()\r\n            Log.d(\"GestureUpdate\", \"curData = $curData \")\r\n\r\n            if (!file.exists()) {\r\n                file.writeText(\r\n                    \"ts td omg0 omg1 omg2 omg3 omg4 omg5 omg6 omg7 omg8 omg9 omg10 omg11 omg12 omg13 omg14 omg15 \" +\r\n                            \"emg0 emg1 emg2 emg3 emg4 emg5 emg6 emg7 bno0 bno1 bno2 prb0 prb1 prb2 prb3 prb4 prb5 \" +\r\n                            \"prb6 prb7 argmax denoize prot state id now\\n\"\r\n                )\r\n            }\r\n            var line = \"\"\r\n            if (data.isNotEmpty())\r\n                line = data.dropLast(2)\r\n            if (isAppend) {\r\n//                file.appendText(\r\n//                    \"$line $prot ${curData[\"state\"]} ${curData[\"id\"]} ${\r\n//                        ((curData[\"generalTime\"]?.toDouble()?.div(10)?.roundToInt()\r\n//                            ?.div(100.0)) ?: curData[\"generalTime\"]).toString()\r\n//                    }\\n\"\r\n//                )\r\n            } else\r\n                file.writeText(line)\r\n            prot++\r\n            val fileContent = file.readText()\r\n            Log.i(\"FileInfo\", \"File contain: $fileContent\")\r\n\r\n        } catch (e: IOException) {\r\n            Log.i(\"file_writing_error\", \"File writing failed: $e\")\r\n        }\r\n    }\r\n\r\n    private fun learningPreprocessingParse() {\r\n        var lines = requireContext().assets.open(\"data.emg8.protocol\").bufferedReader().readLines()\r\n        lines = lines.drop(1)\r\n        for (line in lines) {\r\n            gestures.add(\r\n                mapOf(\r\n                    \"n\" to line.split(\",\")[0],\r\n                    \"state\" to line.split(\",\")[1],\r\n                    \"id\" to line.split(\",\")[2],\r\n                    \"indicativeTime\" to line.split(\",\")[4]\r\n                )\r\n            )\r\n        }\r\n//        dataCollection = Gson().fromJson(\r\n//            requireContext().assets.open(\"config.json\").reader(),\r\n//            object : TypeToken<Map<String, Any>>() {}.type\r\n//        )\r\n    }\r\n\r\n    private fun trainingDataProcessing(): MutableList<GesturePhase> {\r\n        dataCollection = Gson().fromJson(\r\n            requireContext().assets.open(\"config.json\").reader(),\r\n            object : TypeToken<Map<String, Any>>() {}.type\r\n        )\r\n\r\n        val json =\r\n            requireContext().assets.open(\"config.json\").bufferedReader().use { it.readText() }\r\n        val gson = Gson()\r\n        val config: ConfigOMGDataCollection = gson.fromJson(json, ConfigOMGDataCollection::class.java)\r\n\r\n        var lineData = mutableListOf<GesturePhase>()\r\n\r\n        nCycles = config.nCycles ?: 0\r\n//        Log.d(\"trainingDataProcessing\", \"nCycles $nCycles\")\r\n        gestureSequence = config.gestureSequence\r\n//        Log.d(\"trainingDataProcessing\", \"gestureSequence $gestureSequence\")\r\n        gestureNumber = (gestureSequence as ArrayList<*>).size - 1\r\n//        Log.d(\"trainingDataProcessing\", \"gestureNumber $gestureNumber\")\r\n        preGestDuration = config.preGestDuration?.toDouble() ?: 0.0\r\n//        Log.d(\"trainingDataProcessing\", \"preGestDuration $preGestDuration\")\r\n        atGestDuration = config.atGestDuration?.toDouble() ?: 0.0\r\n//        Log.d(\"trainingDataProcessing\", \"atGestDuration $atGestDuration\")\r\n        postGestDuration = config.postGestDuration?.toDouble() ?: 0.0\r\n//        Log.d(\"trainingDataProcessing\", \"postGestDuration $postGestDuration\")\r\n        gestureDuration = (preGestDuration + atGestDuration + postGestDuration).toInt()\r\n//        Log.d(\"trainingDataProcessing\", \"gestureDuration $gestureDuration\")\r\n        gesturesId = config.gesturesId\r\n//        Log.d(\"trainingDataProcessing\", \"gesturesId ${gesturesId}\")\r\n        baselineDuration = config.baselineDuration?.toDouble() ?: 0.0\r\n//        Log.d(\"trainingDataProcessing\", \"baselineDuration $baselineDuration\")\r\n        lineData.add(GesturePhase(\r\n            prePhase = 0.0,\r\n            timeGesture = baselineDuration,\r\n            postPhase = 0.0,\r\n            animation = 0,\r\n            headerText = \"Подготовьтесь к выполнению первого жеста\",\r\n            description = \"Подготовьтесь к выполнению первого жеста\",\r\n            gestureName = \"BaseLine\",\r\n            gestureId = -1\r\n        ))\r\n\r\n        gestureSequence.forEach {\r\n//            Log.d(\"trainingDataProcessing\", \"getGestureValueByName ${gesturesId?.getGestureValueByName(it)}\")\r\n            //TODO дописать генерацию ресурса анимации по имени текущего обрабатываемого жеста\r\n            var animation = 0\r\n            if (it == \"ThumbFingers\") {animation = R.raw.loading_training_animation} // тут вместо рандомной ссылки дописать соответствующую\r\n            lineData.add(GesturePhase(\r\n                prePhase = preGestDuration,\r\n                timeGesture = atGestDuration,\r\n                postPhase = postGestDuration,\r\n                animation = animation,\r\n                headerText = \"Подготовьтесь к выполнению первого жеста\",\r\n                description = \"Подготовьтесь к выполнению первого жеста\",\r\n                gestureName = it,\r\n                gestureId = gesturesId?.getGestureValueByName(it) ?: 0\r\n            ))\r\n        }\r\n\r\n        lineData.add(GesturePhase(\r\n            prePhase = 0.0,\r\n            timeGesture = baselineDuration,\r\n            postPhase = 0.0,\r\n            animation = 0,\r\n            headerText = \"Подготовьтесь к выполнению первого жеста\",\r\n            description = \"Подготовьтесь к выполнению первого жеста\",\r\n            gestureName = \"Finish\",\r\n            gestureId = -1\r\n        ))\r\n\r\n//        if (generalTime < baselineDuration)\r\n//            return mapOf(\r\n//                \"n\" to \"0\",\r\n//                \"state\" to \"Baseline\",\r\n//                \"id\" to \"-1\",\r\n//                \"generalTime\" to (generalTime * 1000).toInt().toString(),\r\n//                \"stepTime\" to preGestDuration.toString(),\r\n//            )\r\n//        val currentTime = generalTime - baselineDuration\r\n//        val currentLoop = (currentTime / (gestureNumber * gestureDuration)).toInt()\r\n//        val timeInLoop = currentTime % (gestureNumber * gestureDuration)\r\n//        val gestureInd = (timeInLoop / gestureDuration).toInt() + 1\r\n//        val timeInGesture = timeInLoop % gestureDuration\r\n//        val overallGestureNumber = currentLoop * gestureNumber + gestureInd\r\n//        if (currentLoop > nCycles) {\r\n//            return mapOf(\r\n//                \"n\" to overallGestureNumber.toString(),\r\n//                \"state\" to \"Finish\",\r\n//                \"id\" to \"-1\",\r\n//                \"generalTime\" to (generalTime * 1000).toInt().toString(),\r\n//                \"stepTime\" to postGestDuration.toString(),\r\n//            )\r\n//        }\r\n//        if (preGestDuration < timeInGesture && timeInGesture <= preGestDuration + atGestDuration)\r\n//            lineData = mapOf(\r\n//                \"n\" to overallGestureNumber.toString(),\r\n//                \"state\" to gestureSequence[gestureInd].toString(),\r\n//                \"id\" to (gesturesId as Map<*, *>)[gestureSequence[gestureInd].toString()].toString(),\r\n//                \"generalTime\" to (generalTime * 1000).toInt().toString(),\r\n//                \"stepTime\" to atGestDuration.toString(),\r\n//            )\r\n//        else\r\n//            lineData = mapOf(\r\n//                \"n\" to overallGestureNumber.toString(),\r\n//                \"state\" to \"Neutral\",\r\n//                \"id\" to \"0\",\r\n//                \"generalTime\" to generalTime.toString(),\r\n//                \"stepTime\" to preGestDuration.toString(),\r\n//            )\r\n\r\n        return lineData\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        Log.d(\"LagSpr\", \"Motion onDestroy\")\r\n        _bindig = null\r\n        timer?.cancel()\r\n        preparationTimer?.cancel()\r\n        disposables.clear()\r\n    }\r\n\r\n    private fun startCountdown() {\r\n\r\n        timer = object : CountDownTimer(countDownTime, interval) {\r\n            override fun onTick(millisUntilFinished: Long) {\r\n\r\n                val secondsRemaining = (millisUntilFinished / 1000).toInt()\r\n                binding.countdownTextView.text = secondsRemaining.toString()\r\n                val progress = (millisUntilFinished / interval).toInt()\r\n                binding.motionProgressBar.progress = progress\r\n\r\n            }\r\n\r\n            override fun onFinish() {\r\n                binding.countdownTextView.text = \"0\"\r\n                binding.countdownTextView.visibility = View.GONE\r\n                // Переход к следующему жесту\r\n                currentGestureIndex = (currentGestureIndex + 1) % sprGestureItemList.size\r\n                //TODO вместо currentGestureIndex использоваться кол-во оставшихся фаз\r\n                if (currentGestureIndex == 0) {\r\n                    binding.motionProgressBar.progress = 0\r\n                    binding.motionProgressBar.trackColor = Color.TRANSPARENT\r\n                    showConfirmCompletedTrainingDialog {\r\n                        parentFragmentManager.beginTransaction().replace(\r\n                            R.id.fragmentContainer, SprTrainingFragment()\r\n                        ).commitNow()\r\n                    }\r\n                } else {\r\n                    //TODO запуск следующей фазы\r\n\r\n                }\r\n            }\r\n        }.start()\r\n    }\r\n}\r\n\r\n//    private fun startTrainingSequence() {\r\n//        if (gestureIndex >= gestureConfig.gestureSequence.size) {\r\n//            // Если это первый жест, добавим фазу BASELINE\r\n//            if (gestureIndex == -1) {\r\n//                startBaselinePhase()\r\n//            } else {\r\n//                startPerformGesturePhase()\r\n//            }\r\n//        } else {\r\n//            // Завершение тренировки\r\n//            showConfirmCompletedTrainingDialog {\r\n//                parentFragmentManager.beginTransaction().replace(\r\n//                    R.id.fragmentContainer, SprTrainingFragment()\r\n//                ).commitNow()\r\n//            }\r\n//        }\r\n//    }\r\n//\r\n//    private fun startBaselinePhase() {\r\n//        Log.d(\"GestureUpdate\", \"startBaselinePhase START\")\r\n//\r\n//        currentGestureId = 0\r\n//\r\n//\r\n//        // Получаем имя текущего жеста\r\n//        val gestureName = gestureConfig.gestureSequence[gestureIndex]\r\n//        Log.d(\"GestureUpdate\", \"startBaselinePhase Name: $gestureName (Index: $currentGestureId)\")\r\n//\r\n//        // Устанавливаем текст и видимость для подготовительного этапа\r\n//        binding.prepareForPerformTv.text = \"Подготовьтесь к выполнению жеста\"\r\n//        binding.prepareForPerformTv.visibility = View.VISIBLE\r\n//        binding.motionProgressBar.visibility = View.INVISIBLE\r\n//        binding.countdownTextView.visibility = View.VISIBLE\r\n//\r\n//        // Устанавливаем общее время для фазы BASELINE + PREPARE\r\n//        val baselineAndPrepareDuration = baselineDuration + preGestDuration\r\n//        binding.countdownTextView.text =\r\n//            (baselineAndPrepareDuration / 1000).toString() // Отображаем общее время в секундах\r\n//\r\n//        // Устанавливаем ID для BASELINE\r\n//\r\n//        Log.d(\"GestureUpdate\", \"Current Gesture Index: $currentGestureIndex\")\r\n//\r\n//        // Запускаем таймер для фазы BASELINE + PREPARE\r\n//        timer = object : CountDownTimer(baselineAndPrepareDuration.toLong(), 1000) {\r\n//            override fun onTick(millisUntilFinished: Long) {\r\n//                // Обновляем текст обратного отсчета каждую секунду\r\n//                val secondsRemaining = (millisUntilFinished / 1000).toInt()\r\n//                binding.countdownTextView.text = secondsRemaining.toString()\r\n//            }\r\n//\r\n//            override fun onFinish() {\r\n//                // Переход к следующей фазе подготовки жеста\r\n//                currentGestureId = 0\r\n//                binding.countdownTextView.visibility = View.GONE\r\n//                startPerformGesturePhase()\r\n//            }\r\n//        }.start()\r\n//    }\r\n//\r\n//    private fun startPreparationPhase() {\r\n//        val gestureName = gestureConfig.gestureSequence[gestureIndex]\r\n//        updateGestures(gestureName)\r\n//        binding.prepareForPerformTv.visibility = View.VISIBLE\r\n//        binding.motionProgressBar.visibility = View.INVISIBLE\r\n//        binding.countdownTextView.visibility = View.VISIBLE\r\n//        binding.countdownTextView.text = (gestureConfig.preGestDuration / 1000).toString()\r\n//        // Установите ID жеста на соответствующий из GESTURES_ID\r\n////        currentGestureId = gestureConfig.gesturesId[gestureName] ?: 0\r\n//\r\n//        timer = object : CountDownTimer(preGestDuration.toLong(), 1000) {\r\n//            override fun onTick(millisUntilFinished: Long) {\r\n//                val secondsRemaining = (millisUntilFinished / 1000).toInt()\r\n//                binding.countdownTextView.text = secondsRemaining.toString()\r\n//            }\r\n//\r\n//            override fun onFinish() {\r\n//                binding.countdownTextView.visibility = View.GONE\r\n//                startPerformGesturePhase()\r\n//            }\r\n//        }.start()\r\n//    }\r\n//\r\n//    private fun startPerformGesturePhase() {\r\n//        val gestureName = gestureConfig.gestureSequence[currentGestureIndex]\r\n//        updateGestures(gestureName)\r\n//        binding.prepareForPerformTv.text = \"Выполните жест\"\r\n//        binding.prepareForPerformTv.visibility = View.VISIBLE\r\n//        binding.motionProgressBar.visibility = View.VISIBLE\r\n//        binding.countdownTextView.visibility = View.VISIBLE\r\n//        binding.countdownTextView.text = (atGestDuration / 1000).toString()\r\n//        binding.motionProgressBar.max = (atGestDuration / 30).toInt()\r\n//        isCountingDown = true\r\n//\r\n//        timer = object : CountDownTimer(atGestDuration.toLong(), 30) {\r\n//            override fun onTick(millisUntilFinished: Long) {\r\n//                val progress = (millisUntilFinished / 30).toInt()\r\n//                binding.motionProgressBar.progress = progress\r\n//            }\r\n//\r\n//            override fun onFinish() {\r\n//                binding.countdownTextView.visibility = View.GONE\r\n//                startNeutralPhase()\r\n//            }\r\n//        }.start()\r\n//    }\r\n//\r\n//    private fun startNeutralPhase() {\r\n//        val gestureName = \"Neutral\"\r\n//        updateGestures(gestureName)\r\n//        binding.prepareForPerformTv.text = \"Подготовьтесь к выполнению жеста\"\r\n//        binding.prepareForPerformTv.visibility = View.VISIBLE\r\n//        binding.motionProgressBar.visibility = View.INVISIBLE\r\n//        binding.countdownTextView.visibility = View.VISIBLE\r\n//        binding.countdownTextView.text = ((preGestDuration + postGestDuration) / 1000).toString()\r\n//        currentGestureId = 0\r\n//\r\n//        timer = object : CountDownTimer((preGestDuration + postGestDuration).toLong(), 1000) {\r\n//            override fun onTick(millisUntilFinished: Long) {\r\n//                val secondsRemaining = (millisUntilFinished / 1000).toInt()\r\n//                binding.countdownTextView.text = secondsRemaining.toString()\r\n//            }\r\n//\r\n//            override fun onFinish() {\r\n//                binding.countdownTextView.visibility = View.GONE\r\n//                currentGestureIndex++\r\n//                startTrainingSequence()\r\n//            }\r\n//        }.start()\r\n//    }\r\n//\r\n//\r\n//    private fun updateGestures() {\r\n//        val currentGestures = sprGestureItemList[currentGestureIndex]\r\n//        binding.motionHandIv.setImageResource(currentGestures.image)\r\n//        binding.motionNameOfGesturesTv.text = currentGestures.title\r\n//    }\r\n//\r\n//    private fun startPreparationCountDown() {\r\n//        binding.prepareForPerformTv.visibility = View.VISIBLE\r\n//        binding.motionProgressBar.visibility = View.INVISIBLE\r\n//        updateGestures()\r\n//        isCountingDown = false\r\n//        preparationTimer = object : CountDownTimer(pauseBeforeStart, 1000) {\r\n//            override fun onTick(millisUntilFinished: Long) {\r\n//                val secondsRemaining = (millisUntilFinished / 1000).toInt()\r\n//                binding.countdownTextView.text = secondsRemaining.toString()\r\n//                binding.countdownTextView.visibility = View.VISIBLE\r\n//            }\r\n//\r\n//            override fun onFinish() {\r\n//                binding.prepareForPerformTv.visibility = View.INVISIBLE\r\n//                binding.motionProgressBar.visibility = View.VISIBLE\r\n//                isCountingDown = true\r\n//                startCountdown()\r\n//            }\r\n//\r\n//        }.start()\r\n//    }\r\n//\r\n\r\n//    }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/bailout/stickk/ubi4/ui/fragments/MotionTrainingFragment.kt b/app/src/main/java/com/bailout/stickk/ubi4/ui/fragments/MotionTrainingFragment.kt
--- a/app/src/main/java/com/bailout/stickk/ubi4/ui/fragments/MotionTrainingFragment.kt	(revision 2e86270d31f9f3c3a5c83efb1c8c55f93434d15e)
+++ b/app/src/main/java/com/bailout/stickk/ubi4/ui/fragments/MotionTrainingFragment.kt	(date 1733738584560)
@@ -25,6 +25,7 @@
 import com.bailout.stickk.ubi4.models.SprGestureItem
 import com.bailout.stickk.ubi4.rx.RxUpdateMainEventUbi4
 import com.bailout.stickk.ubi4.ui.main.MainActivityUBI4.Companion.main
+import com.bailout.stickk.ubi4.utility.SprGestureItemsProvider
 import com.google.gson.Gson
 import com.google.gson.reflect.TypeToken
 import io.reactivex.disposables.CompositeDisposable
@@ -43,7 +44,7 @@
     private val countDownTime = 0L
     private val interval = 30L
     private val pauseBeforeStart = 100L
-    private lateinit var sprGestureItemList: ArrayList<SprGestureItem>
+    private var sprGestureItemList: ArrayList<SprGestureItem> = SprGestureItemsProvider().getSprGestureItemList(requireContext())
     var currentGestureIndex = 0
     private var timer: CountDownTimer? = null
     private var preparationTimer: CountDownTimer? = null
@@ -213,7 +214,7 @@
         }
 
 
-//        val gestureItemsProvider = SprGestureItemsProvider()
+//        gestureItemsProvider = SprGestureItemsProvider()
 //        sprGestureItemList = gestureItemsProvider.getSprGestureItemList(requireContext())
 //        startPreparationCountDown()
 
@@ -441,9 +442,12 @@
         val json =
             requireContext().assets.open("config.json").bufferedReader().use { it.readText() }
         val gson = Gson()
-        val config: ConfigOMGDataCollection = gson.fromJson(json, ConfigOMGDataCollection::class.java)
+        val config: ConfigOMGDataCollection =
+            gson.fromJson(json, ConfigOMGDataCollection::class.java)
 
         var lineData = mutableListOf<GesturePhase>()
+        var previousGesture: GesturePhase? = null
+
 
         nCycles = config.nCycles ?: 0
 //        Log.d("trainingDataProcessing", "nCycles $nCycles")
@@ -463,44 +467,132 @@
 //        Log.d("trainingDataProcessing", "gesturesId ${gesturesId}")
         baselineDuration = config.baselineDuration?.toDouble() ?: 0.0
 //        Log.d("trainingDataProcessing", "baselineDuration $baselineDuration")
-        lineData.add(GesturePhase(
-            prePhase = 0.0,
-            timeGesture = baselineDuration,
-            postPhase = 0.0,
-            animation = 0,
-            headerText = "Подготовьтесь к выполнению первого жеста",
-            description = "Подготовьтесь к выполнению первого жеста",
-            gestureName = "BaseLine",
-            gestureId = -1
-        ))
+        lineData.add(
+            GesturePhase(
+                prePhase = 0.0,
+                timeGesture = baselineDuration,
+                postPhase = 0.0,
+                animation = 0,
+                headerText = "Подготовьтесь к выполнению первого жеста",
+                description = "Подготовьтесь к выполнению первого жеста",
+                gestureName = "BaseLine",
+                gestureId = -1
+            )
+        )
 
-        gestureSequence.forEach {
+        //добавление этапов для каждого жеста
+        gestureSequence.forEachIndexed { index, gestureName ->
 //            Log.d("trainingDataProcessing", "getGestureValueByName ${gesturesId?.getGestureValueByName(it)}")
             //TODO дописать генерацию ресурса анимации по имени текущего обрабатываемого жеста
             var animation = 0
-            if (it == "ThumbFingers") {animation = R.raw.loading_training_animation} // тут вместо рандомной ссылки дописать соответствующую
-            lineData.add(GesturePhase(
+            when (gestureName) {
+                "ThumbFingers" -> animation =
+                    R.raw.loading_training_animation // тут вместо рандомной ссылки дописать соответствующую
+            }
+
+            val gestureId = gesturesId?.getGestureValueByName(gestureName) ?: run {
+                Log.e("MotionTrainingFragment", "Unknown gesture name: $gestureName")
+                0
+            }
+
+            if (index < gestureSequence.size) {
+                // Получение ID для Neutral фазы
+                val neutralId = gesturesId?.getGestureValueByName("Neutral") ?: run {
+                    Log.e("MotionTrainingFragment", "Neutral gesture ID not found")
+                    0
+                }
+                val neutralPhase = GesturePhase(
+                    prePhase = 0.0,
+                    timeGesture = postGestDuration + preGestDuration,
+                    postPhase = 0.0,
+                    animation = 0,
+                    headerText = "Подготовьтесь к выполнению жеста",
+                    description = "Отдохните перед следующим жестом",
+                    gestureName = "Neutral",
+                    gestureId = neutralId
+                )
+                lineData.add(neutralPhase)
+
+
+            }
+
+            val currentGesture = GesturePhase(
                 prePhase = preGestDuration,
                 timeGesture = atGestDuration,
                 postPhase = postGestDuration,
                 animation = animation,
-                headerText = "Подготовьтесь к выполнению первого жеста",
-                description = "Подготовьтесь к выполнению первого жеста",
-                gestureName = it,
-                gestureId = gesturesId?.getGestureValueByName(it) ?: 0
-            ))
-        }
+                headerText = "Подготовьтесь к выполнению жеста",
+                description = "Выполните жест: $gestureName",
+                gestureName = gestureName,
+                gestureId = gestureId
+            )
+            lineData.add(currentGesture)
+
+
 
-        lineData.add(GesturePhase(
-            prePhase = 0.0,
-            timeGesture = baselineDuration,
-            postPhase = 0.0,
-            animation = 0,
-            headerText = "Подготовьтесь к выполнению первого жеста",
-            description = "Подготовьтесь к выполнению первого жеста",
-            gestureName = "Finish",
-            gestureId = -1
-        ))
+        }
+        lineData.add(
+            GesturePhase(
+                prePhase = 0.0,
+                timeGesture = baselineDuration,
+                postPhase = 0.0,
+                animation = 0,
+                headerText = "Отдохните перед следующим жестом",
+                description = "Отдохните перед следующим жестом",
+                gestureName = "Finish",
+                gestureId = -1
+            )
+        )
+
+
+
+        return lineData
+    }
+
+    override fun onDestroy() {
+        super.onDestroy()
+        Log.d("LagSpr", "Motion onDestroy")
+        _bindig = null
+        timer?.cancel()
+        preparationTimer?.cancel()
+        disposables.clear()
+    }
+
+    private fun startCountdown() {
+
+        timer = object : CountDownTimer(countDownTime, interval) {
+            override fun onTick(millisUntilFinished: Long) {
+
+                val secondsRemaining = (millisUntilFinished / 1000).toInt()
+                binding.countdownTextView.text = secondsRemaining.toString()
+                val progress = (millisUntilFinished / interval).toInt()
+                binding.motionProgressBar.progress = progress
+
+            }
+
+            override fun onFinish() {
+                binding.countdownTextView.text = "0"
+                binding.countdownTextView.visibility = View.GONE
+                // Переход к следующему жесту
+                currentGestureIndex = (currentGestureIndex + 1) % sprGestureItemList.size
+                //TODO вместо currentGestureIndex использоваться кол-во оставшихся фаз
+                if (currentGestureIndex == 0) {
+                    binding.motionProgressBar.progress = 0
+                    binding.motionProgressBar.trackColor = Color.TRANSPARENT
+                    showConfirmCompletedTrainingDialog {
+                        parentFragmentManager.beginTransaction().replace(
+                            R.id.fragmentContainer, SprTrainingFragment()
+                        ).commitNow()
+                    }
+                } else {
+                    //TODO запуск следующей фазы
+
+                }
+            }
+        }.start()
+    }
+}
+
 
 //        if (generalTime < baselineDuration)
 //            return mapOf(
@@ -542,52 +634,6 @@
 //                "stepTime" to preGestDuration.toString(),
 //            )
 
-        return lineData
-    }
-
-    override fun onDestroy() {
-        super.onDestroy()
-        Log.d("LagSpr", "Motion onDestroy")
-        _bindig = null
-        timer?.cancel()
-        preparationTimer?.cancel()
-        disposables.clear()
-    }
-
-    private fun startCountdown() {
-
-        timer = object : CountDownTimer(countDownTime, interval) {
-            override fun onTick(millisUntilFinished: Long) {
-
-                val secondsRemaining = (millisUntilFinished / 1000).toInt()
-                binding.countdownTextView.text = secondsRemaining.toString()
-                val progress = (millisUntilFinished / interval).toInt()
-                binding.motionProgressBar.progress = progress
-
-            }
-
-            override fun onFinish() {
-                binding.countdownTextView.text = "0"
-                binding.countdownTextView.visibility = View.GONE
-                // Переход к следующему жесту
-                currentGestureIndex = (currentGestureIndex + 1) % sprGestureItemList.size
-                //TODO вместо currentGestureIndex использоваться кол-во оставшихся фаз
-                if (currentGestureIndex == 0) {
-                    binding.motionProgressBar.progress = 0
-                    binding.motionProgressBar.trackColor = Color.TRANSPARENT
-                    showConfirmCompletedTrainingDialog {
-                        parentFragmentManager.beginTransaction().replace(
-                            R.id.fragmentContainer, SprTrainingFragment()
-                        ).commitNow()
-                    }
-                } else {
-                    //TODO запуск следующей фазы
-
-                }
-            }
-        }.start()
-    }
-}
 
 //    private fun startTrainingSequence() {
 //        if (gestureIndex >= gestureConfig.gestureSequence.size) {
Index: app/src/main/java/com/bailout/stickk/ubi4/models/Models.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.bailout.stickk.ubi4.models\r\n\r\nimport com.bailout.stickk.ubi4.data.local.Gesture\r\nimport com.google.gson.annotations.SerializedName\r\nimport java.io.File\r\n\r\n//widgets items\r\ndata class GesturesItem(val title: String, val widget: Any)\r\ndata class OneButtonItem(val title: String, val description: String, val widget: Any)\r\ndata class PlotItem(val title: String, val widget: Any)\r\ndata class SliderItem(val title: String, val widget: Any)\r\ndata class SwitchItem(val title: String, val widget: Any)\r\ndata class TrainingGestureItem(val title: String, val widget: Any)\r\ndata class FileItem(val name: String, val file: File)\r\n\r\n// dialogs\r\ndata class DialogCollectionGestureItem(val gesture: Gesture, var check: Boolean = false)\r\ndata class SprGestureItem(val title: String, val image: Int, var check: Boolean)\r\ndata class BindingGestureItem(\r\n    val position: Int,\r\n    var nameOfUserGesture: String,\r\n    val sprGestureItem: SprGestureItem\r\n)\r\n\r\n// приём и передача данных в потоках ble\r\ndata class ParameterRef(\r\n    val addressDevice: Int, val parameterID: Int\r\n)\r\n\r\ndata class PlotParameterRef(\r\n    val addressDevice: Int, val parameterID: Int, val dataPlots: ArrayList<Int>\r\n)\r\n\r\n// 3D конфигуратор и передача информации о жесте\r\ndata class GestureInfo(\r\n    val deviceAddress: Int, val parameterID: Int, val gestureID: Int\r\n)\r\n\r\ndata class GestureWithAddress(\r\n    val addressDevice: Int, val parameterID: Int,\r\n    val gesture: Gesture, val gestureState: Int\r\n)\r\n\r\ndata class GestureConfig(\r\n    val baselineDuration: Double,\r\n    val preGestDuration: Double,\r\n    val atGestDuration: Double,\r\n    val postGestDuration: Double,\r\n    val gestureSequence: List<String>,\r\n//    val gesturesId: Map<String, Int>\r\n)\r\n\r\ndata class GesturePhase(\r\n    var prePhase: Double = 0.0,\r\n    var timeGesture: Double = 0.0,\r\n    var postPhase: Double = 0.0,\r\n    var animation: Int = 0,\r\n    var headerText: String = \"\",\r\n    var description: String = \"\",\r\n    var gestureName: String = \"\",\r\n    var gestureId: Int = 0\r\n)\r\n\r\ndata class ConfigOMGDataCollection(\r\n    @SerializedName(\"FPATH\") var fPath: String? = null,\r\n    @SerializedName(\"DF_PROTOCOL_HEADER\") var dFProtocolHeader: ArrayList<String> = arrayListOf(),\r\n    @SerializedName(\"BASELINE_DURATION\") var baselineDuration: Int? = null,\r\n    @SerializedName(\"PRE_GEST_DURATION\") var preGestDuration: Int? = null,\r\n    @SerializedName(\"AT_GEST_DURATION\") var atGestDuration: Int? = null,\r\n    @SerializedName(\"POST_GEST_DURATION\") var postGestDuration: Int? = null,\r\n    @SerializedName(\"N_CYCLES\") var nCycles: Int? = null,\r\n    @SerializedName(\"N_OMG_CH\") var nOmgCh: Int? = null,\r\n    @SerializedName(\"N_EMG_CH\") var nEmgCh: Int? = null,\r\n    @SerializedName(\"N_BNO_CH\") var nBnoCh: Int? = null,\r\n    @SerializedName(\"IS_ML\") var isMl: Boolean? = null,\r\n    @SerializedName(\"N_ML_CH\") var nMlCh: Int? = null,\r\n    @SerializedName(\"GESTURES_ID\") var gesturesId: GesturesId? = GesturesId(),\r\n    @SerializedName(\"GESTURE_SEQUENCE\") var gestureSequence: ArrayList<String> = arrayListOf(),\r\n    @SerializedName(\"HEADER\") var header: String? = null,\r\n    @SerializedName(\"FNAME\") var fName: String? = null,\r\n    @SerializedName(\"FPROTNAME\") var fProtName: String? = null,\r\n    @SerializedName(\"FHEADER\") var fHeader: String? = null,\r\n    @SerializedName(\"N_COLS\") var nCols: Int? = null\r\n)\r\n\r\ndata class GesturesId(\r\n    @SerializedName(\"Neutral\") var Neutral: String? = null,\r\n    @SerializedName(\"ThumbFingers\") var ThumbFingers: String? = null,\r\n    @SerializedName(\"Close\") var Close: String? = null,\r\n    @SerializedName(\"Open\") var Open: String? = null,\r\n    @SerializedName(\"Pinch\") var Pinch: String? = null,\r\n    @SerializedName(\"Indication\") var Indication: String? = null,\r\n    @SerializedName(\"Wrist_Flex\") var WristFlex: String? = null,\r\n    @SerializedName(\"Wrist_Extend\") var WristExtend: String? = null,\r\n) {\r\n    // Метод для получения имени жеста по значению\r\n    fun getGestureNameByValue(value: Int): String? {\r\n        return mapOf(\r\n            Neutral?.toIntOrNull() to \"Neutral\",\r\n            ThumbFingers?.toIntOrNull() to \"ThumbFingers\",\r\n            Close?.toIntOrNull() to \"Close\",\r\n            Open?.toIntOrNull() to \"Open\",\r\n            Pinch?.toIntOrNull() to \"Pinch\",\r\n            Indication?.toIntOrNull() to \"Indication\",\r\n            WristFlex?.toIntOrNull() to \"Wrist_Flex\",\r\n            WristExtend?.toIntOrNull() to \"Wrist_Extend\"\r\n        )[value]\r\n    }\r\n\r\n    // Метод для получения значения жеста по имени\r\n    fun getGestureValueByName(name: String): Int? {\r\n        return when (name) {\r\n            \"Neutral\" -> Neutral?.toIntOrNull()\r\n            \"ThumbFingers\" -> ThumbFingers?.toIntOrNull()\r\n            \"Close\" -> Close?.toIntOrNull()\r\n            \"Open\" -> Open?.toIntOrNull()\r\n            \"Pinch\" -> Pinch?.toIntOrNull()\r\n            \"Indication\" -> Indication?.toIntOrNull()\r\n            \"Wrist_Flex\" -> WristFlex?.toIntOrNull()\r\n            \"Wrist_Extend\" -> WristExtend?.toIntOrNull()\r\n            else -> null\r\n        }\r\n    }\r\n}\r\n\r\n// Базовая фаза (Baseline)\r\n//data class PhaseBaseline(\r\n//    override val prePhase: Int = 0,\r\n//    override val timeGesture: Double = 5.0, // BASELINE_DURATION\r\n//    override val postPhase: Int = 0,\r\n//    override val animation: Int = 0,\r\n//    override val headerText: String = \"Подготовьтесь к выполнению жеста\",\r\n//    override val description: String = \"\",\r\n//    override val gestureName: String = \"Baseline\", // так как это baseline состояние\r\n//    override val gestureId: Int = -1 // baseline всегда -1\r\n//) : GesturePhase()\r\n//\r\n//// Pre-фаза\r\n//data class PhasePre(\r\n//    override val prePhase: Int = 0,\r\n//    override val timeGesture: Double = 2.0, // PRE_GEST_DURATION\r\n//    override val postPhase: Int = 0,\r\n//    override val animation: Int = 0,\r\n//    override val headerText: String = \"Подготовьтесь к выполнению жеста\",\r\n//    override val description: String = \"\",\r\n//    override val gestureName: String,\r\n//    override val gestureId: Int\r\n//) : GesturePhase()\r\n//\r\n//// At-фаза (выполнение жеста)\r\n//data class PhaseAt(\r\n//    override val prePhase: Int = 0,\r\n//    override val timeGesture: Double = 2.0, // AT_GEST_DURATION\r\n//    override val postPhase: Int = 0,\r\n//    override val animation: Int = 0,\r\n//    override val headerText: String = \"Выполните жест\",\r\n//    override val description: String = \"\",\r\n//    override val gestureName: String,\r\n//    override val gestureId: Int\r\n//) : GesturePhase()\r\n//\r\n//// Post-фаза\r\n//data class PhasePost(\r\n//    override val prePhase: Int = 0,\r\n//    override val timeGesture: Double = 2.0, // POST_GEST_DURATION\r\n//    override val postPhase: Int = 0,\r\n//    override val animation: Int = 0,\r\n//    override val headerText: String = \"Подготовьтесь к выполнению жеста\",\r\n//    override val description: String = \"\",\r\n//    override val gestureName: String,\r\n//    override val gestureId: Int\r\n//) : GesturePhase()\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/bailout/stickk/ubi4/models/Models.kt b/app/src/main/java/com/bailout/stickk/ubi4/models/Models.kt
--- a/app/src/main/java/com/bailout/stickk/ubi4/models/Models.kt	(revision 2e86270d31f9f3c3a5c83efb1c8c55f93434d15e)
+++ b/app/src/main/java/com/bailout/stickk/ubi4/models/Models.kt	(date 1733738584541)
@@ -15,7 +15,7 @@
 
 // dialogs
 data class DialogCollectionGestureItem(val gesture: Gesture, var check: Boolean = false)
-data class SprGestureItem(val title: String, val image: Int, var check: Boolean)
+data class SprGestureItem(val title: String, val animationId: Int, var check: Boolean, val keyNameGesture: String )
 data class BindingGestureItem(
     val position: Int,
     var nameOfUserGesture: String,
Index: .gradle/config.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#Fri Dec 06 20:26:40 MSK 2024\r\njava.home=/Applications/Android Studio 2.app/Contents/jbr/Contents/Home\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/.gradle/config.properties b/.gradle/config.properties
--- a/.gradle/config.properties	(revision 2e86270d31f9f3c3a5c83efb1c8c55f93434d15e)
+++ b/.gradle/config.properties	(date 1733730595841)
@@ -1,2 +1,2 @@
-#Fri Dec 06 20:26:40 MSK 2024
-java.home=/Applications/Android Studio 2.app/Contents/jbr/Contents/Home
+#Mon Dec 09 10:49:55 MSK 2024
+java.home=C\:\\Program Files\\Android\\Android Studio\\jbr
Index: local.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>## This file must *NOT* be checked into Version Control Systems,\r\n# as it contains information specific to your local configuration.\r\n#\r\n# Location of the SDK. This is only used by Gradle.\r\n# For customization when using a Version Control System, please read the\r\n# header note.\r\n#Fri Dec 06 20:26:44 MSK 2024\r\nsdk.dir=/Users/motoricallc/Library/Android/sdk\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/local.properties b/local.properties
--- a/local.properties	(revision 2e86270d31f9f3c3a5c83efb1c8c55f93434d15e)
+++ b/local.properties	(date 1733730601611)
@@ -4,5 +4,5 @@
 # Location of the SDK. This is only used by Gradle.
 # For customization when using a Version Control System, please read the
 # header note.
-#Fri Dec 06 20:26:44 MSK 2024
-sdk.dir=/Users/motoricallc/Library/Android/sdk
+#Mon Dec 09 10:50:01 MSK 2024
+sdk.dir=C\:\\Users\\touro\\AppData\\Local\\Android\\Sdk
