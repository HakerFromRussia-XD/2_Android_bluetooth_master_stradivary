Index: app/src/main/java/com/bailout/stickk/ubi4/ui/fragments/base/BaseWidgetsFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.bailout.stickk.ubi4.ui.fragments.base\n\nimport android.annotation.SuppressLint\nimport android.app.Dialog\nimport android.content.Intent\nimport android.graphics.Color\nimport android.graphics.drawable.ColorDrawable\nimport android.os.Bundle\nimport android.util.Log\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport android.widget.TextView\nimport androidx.fragment.app.Fragment\nimport androidx.lifecycle.lifecycleScope\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport androidx.recyclerview.widget.RecyclerView\nimport com.bailout.stickk.R\nimport com.bailout.stickk.ubi4.adapters.dialog.GesturesCheckAdapter\nimport com.bailout.stickk.ubi4.adapters.dialog.OnCheckGestureListener\nimport com.bailout.stickk.ubi4.adapters.dialog.OnCheckSprGestureListener2\nimport com.bailout.stickk.ubi4.adapters.dialog.SprGesturesCheckAdapter\nimport com.bailout.stickk.ubi4.adapters.widgetDelegeteAdapters.GesturesOpticDelegateAdapter\nimport com.bailout.stickk.ubi4.adapters.widgetDelegeteAdapters.OneButtonDelegateAdapter\nimport com.bailout.stickk.ubi4.adapters.widgetDelegeteAdapters.PlotDelegateAdapter\nimport com.bailout.stickk.ubi4.adapters.widgetDelegeteAdapters.SliderDelegateAdapter\nimport com.bailout.stickk.ubi4.adapters.widgetDelegeteAdapters.SpinnerDelegateAdapter\nimport com.bailout.stickk.ubi4.adapters.widgetDelegeteAdapters.SwitcherDelegateAdapter\nimport com.bailout.stickk.ubi4.adapters.widgetDelegeteAdapters.TrainingFragmentDelegateAdapter\nimport com.bailout.stickk.ubi4.ble.BLECommands\nimport com.bailout.stickk.ubi4.ble.BLEController\nimport com.bailout.stickk.ubi4.ble.SampleGattAttributes.MAIN_CHANNEL\nimport com.bailout.stickk.ubi4.ble.SampleGattAttributes.WRITE\nimport com.bailout.stickk.ubi4.contract.navigator\nimport com.bailout.stickk.ubi4.contract.transmitter\nimport com.bailout.stickk.ubi4.data.local.BindingGestureGroup\nimport com.bailout.stickk.ubi4.data.local.CollectionGesturesProvider\nimport com.bailout.stickk.ubi4.data.local.Gesture\nimport com.bailout.stickk.ubi4.data.local.SprGestureItemsProvider\nimport com.bailout.stickk.ubi4.models.dialog.DialogCollectionGestureItem\nimport com.bailout.stickk.ubi4.models.dialog.SprDialogCollectionGestureItem\nimport com.bailout.stickk.ubi4.persistence.preference.PreferenceKeysUBI4\nimport com.bailout.stickk.ubi4.persistence.preference.PreferenceKeysUBI4.DEVICE_ID_IN_SYSTEM_UBI4\nimport com.bailout.stickk.ubi4.persistence.preference.PreferenceKeysUBI4.GESTURE_ID_IN_SYSTEM_UBI4\nimport com.bailout.stickk.ubi4.persistence.preference.PreferenceKeysUBI4.PARAMETER_ID_IN_SYSTEM_UBI4\nimport com.bailout.stickk.ubi4.resources.AndroidResourceProvider\nimport com.bailout.stickk.ubi4.data.state.UiState.listWidgets\nimport com.bailout.stickk.ubi4.ui.gripper.with_encoders.UBI4GripperScreenWithEncodersActivity\nimport com.bailout.stickk.ubi4.ui.main.MainActivityUBI4\nimport com.livermor.delegateadapter.delegate.CompositeDelegateAdapter\n\nabstract class BaseWidgetsFragment : Fragment() {\n    private var gestureNameList = ArrayList<String>()\n    private val onDestroyParentCallbacks = mutableListOf<() -> Unit>()\n    private var onClearSwitcherCache : () -> Unit = {}\n    private var main: MainActivityUBI4? = null\n    private var loadingCurrentDialog: Dialog? = null\n    private lateinit var bleController: BLEController\n    private val collectionGesturesProvider: CollectionGesturesProvider by lazy {\n        CollectionGesturesProvider(AndroidResourceProvider(requireContext()))\n    }\n    protected val adapterWidgets by lazy {\n        CompositeDelegateAdapter(\n            PlotDelegateAdapter(\n                onDestroyParent = { onDestroyParent ->\n                    onDestroyParentCallbacks.add(onDestroyParent)\n                }\n            ),\n            OneButtonDelegateAdapter(\n                onButtonPressed = { device, param, command ->\n                    oneButtonPressed(device, param, command)\n                },\n                onButtonReleased = { device, param, command ->\n                    oneButtonReleased(device, param, command)\n                },\n                onDestroyParent = { onDestroyParent ->\n                    onDestroyParentCallbacks.add(onDestroyParent)\n                }\n            ),\n            //TODO Сделать ячейки GesturesDelegateAdapter и GesturesOpticDelegateAdapter разными\n//            GesturesDelegateAdapter (\n//                gestureNameList = gestureNameList,\n//                onDeleteClick = { resultCb, gestureName -> showDeleteGestureFromRotationGroupDialog(resultCb, gestureName) },\n//                onAddGesturesToRotationGroup = { onSaveDialogClick -> showAddGestureToRotationGroupDialog(onSaveDialogClick) },\n//                onSendBLERotationGroup = {deviceAddress, parameterID -> sendBLERotationGroup(deviceAddress, parameterID) },\n//                onSendBLEActiveGesture = {deviceAddress, parameterID, activeGesture -> sendBLEActiveGesture(deviceAddress, parameterID, activeGesture) },\n//                onShowGestureSettings = { deviceAddress, parameterID, gestureID -> showGestureSettings(deviceAddress, parameterID, gestureID) },\n//                onRequestGestureSettings = {deviceAddress, parameterID, gestureID -> requestGestureSettings(deviceAddress, parameterID, gestureID)},\n//                onRequestRotationGroup = {deviceAddress, parameterID -> requestRotationGroup(deviceAddress, parameterID)},\n//                onDestroyParent = { onDestroyParent -> onDestroyParentCallbacks.add(onDestroyParent)}\n//            ),\n            GesturesOpticDelegateAdapter(\n                coroutineScope = main?.lifecycleScope,\n                gestureNameList = gestureNameList,\n                onDeleteClick = { resultCb, gestureName -> showDeleteGestureFromRotationGroupDialog(resultCb, gestureName) },\n                onAddGesturesToRotationGroup = { onSaveDialogClick -> showAddGestureToRotationGroupDialog(onSaveDialogClick)},\n                onAddGesturesToSprScreen = { onSaveClickDialog, bindingGestureList ->\n                    showControlGesturesDialog(onSaveClickDialog, bindingGestureList)\n                },\n                onShowGestureSettings = { device, param, gestureID ->\n                    showGestureSettings(device, param, gestureID)\n                },\n                onRequestGestureSettings = { device, param, gestureID ->\n                    requestGestureSettings(device, param, gestureID)\n                },\n                onSetCustomGesture = { onSaveDotsClick, bindingItem ->\n                    showCustomGesturesDialog(onSaveDotsClick, bindingItem)\n                },\n                onSendBLEActiveGesture = { deviceAddress, parameterID, activeGesture ->\n                    sendBLEActiveGesture(deviceAddress, parameterID, activeGesture)\n                },\n                onRequestActiveGesture = { deviceAddress, parameterID ->\n                    requestActiveGesture(deviceAddress, parameterID)\n                },\n                onSendBLERotationGroup = {deviceAddress, parameterID -> sendBLERotationGroup(deviceAddress, parameterID)},\n                onSendBLEBindingGroup = { deviceAddress, parameterID, bindingGestureGroup ->\n                    sendBLEBindingGroup(deviceAddress, parameterID, bindingGestureGroup)\n                },\n                onRequestBindingGroup = { deviceAddress, parameterID ->\n                    requestBindingGroup(deviceAddress, parameterID)\n                },\n                onRequestRotationGroup = {deviceAddress, parameterID ->\n                    requestRotationGroup(deviceAddress, parameterID)\n                },\n                onDestroyParent = { onDestroyParent ->\n                    onDestroyParentCallbacks.add(onDestroyParent)\n                }\n            ),\n            TrainingFragmentDelegateAdapter(\n                onConfirmClick = {\n                    if (isAdded) {\n                        Log.d(\"StateCallBack\", \"onConfirmClick: Button clicked\")\n                        showConfirmTrainingDialog {\n                            navigator().showMotionTrainingScreen {\n                                main?.manageTrainingLifecycle()\n                                Log.d(\"StateCallBack\", \"manageTrainingLifecycle() run\")\n\n                            }\n                        }\n                    } else {\n                        Log.e(\"StateCallBack\", \"Fragment is not attached to activity\")\n                    }\n                },\n                onShowFileClick = { addressDevice -> showFilesDialog(addressDevice,6) },\n                onDestroyParent = { onDestroyParent -> onDestroyParentCallbacks.add(onDestroyParent) },\n            ),\n            SwitcherDelegateAdapter(\n                onSwitchClick = { addressDevice, parameterID, switchState ->\n                    sendSwitcherState(addressDevice, parameterID, switchState)\n                },\n                onClearCache = { clearSwitcherCache -> onClearSwitcherCache = clearSwitcherCache},\n                onDestroyParent = { onDestroyParent -> onDestroyParentCallbacks.add(onDestroyParent) }\n            ),\n            SpinnerDelegateAdapter(\n                onSpinnerItemSelected = { addressDevice, parameterID, newIndex ->\n                    Log.d(\"SpinnerDelegate\", \"Selected index $newIndex for device $addressDevice, param $parameterID\")\n                },\n                onDestroyParent = { onDestroyParent -> onDestroyParentCallbacks.add(onDestroyParent) }\n            ),\n            SliderDelegateAdapter(\n                onSetProgress = { addressDevice, parameterID, progress ->\n                    sendSliderProgress(\n                        addressDevice,\n                        parameterID,\n                        progress\n                    )\n                },\n                onDestroyParent = { onDestroyParent -> onDestroyParentCallbacks.add(onDestroyParent) }\n            )\n        )\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        loadGestureNameList()\n        if (activity != null) {\n            main = activity as MainActivityUBI4?\n        }\n    }\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        return super.onCreateView(inflater, container, savedInstanceState)\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        bleController = (requireActivity() as MainActivityUBI4).getBLEController()\n    }\n    override fun onDestroy() {\n        super.onDestroy()\n        onDestroyParentCallbacks.forEach { it.invoke() }\n    }\n\n    //CallBacks\n//    open fun onPlotReady(num: Int) {}\n    open fun oneButtonPressed(addressDevice: Int, parameterID: Int, command: Int) {\n        transmitter().bleCommand(BLECommands.sendOneButtonCommand(addressDevice, parameterID, command), MAIN_CHANNEL, WRITE)\n        Log.d(\"TestButton\", \"oneButtonPressed run\")\n    }\n    open fun oneButtonReleased(addressDevice: Int, parameterID: Int, command: Int) {\n        transmitter().bleCommand(BLECommands.sendOneButtonCommand(addressDevice, parameterID, command), MAIN_CHANNEL, WRITE)\n        Log.d(\"TestButton\", \"oneButtonReleased run\")\n\n    }\n    open fun showControlGesturesDialog(onSaveClickDialog: (MutableList<Pair<Int, Int>>) -> Unit, bindingGestureList:  List<Pair<Int, Int>>) {\n        System.err.println(\"showAddGestureToSprScreen\")\n        val dialogBinding =\n            layoutInflater.inflate(R.layout.ubi4_dialog_gestures_add_to_spr_screen, null)\n        val myDialog = Dialog(requireContext())\n        val gesturesRv = dialogBinding.findViewById<RecyclerView>(R.id.dialogAddGesturesRv)\n\n        var checkedItems = bindingGestureList.map { it.first }\n\n        val linearLayoutManager = LinearLayoutManager(context)\n        myDialog.setContentView(dialogBinding)\n        myDialog.setCancelable(false)\n        myDialog.window!!.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))\n        myDialog.show()\n\n        val sprGestureDialogList: ArrayList<SprDialogCollectionGestureItem> =\n            ArrayList(\n                SprGestureItemsProvider(AndroidResourceProvider(requireContext())).getSprGestureItemList()\n                    .map { SprDialogCollectionGestureItem(it) })\n\n        for (sprDialogCollectionGestureItem in sprGestureDialogList) {\n            bindingGestureList.find { it.first == sprDialogCollectionGestureItem.gesture.sprGestureId }?.let {\n                sprDialogCollectionGestureItem.check = true\n            }\n        }\n        Log.d(\"showControlGesturesDialog\", \"$sprGestureDialogList\")\n\n        linearLayoutManager.orientation = LinearLayoutManager.VERTICAL\n        gesturesRv.layoutManager = linearLayoutManager\n        val adapter =\n            SprGesturesCheckAdapter(sprGestureDialogList, object : OnCheckSprGestureListener2 {\n                override fun onSprGestureClicked2(\n                    position: Int,\n                    sprDialogCollectionGestureItem: SprDialogCollectionGestureItem\n                ) {\n                    // происходит изменение состояние check на противоположное\n                    sprGestureDialogList[position] =\n                        sprGestureDialogList[position].copy(check = !sprGestureDialogList[position].check)\n                    //происходит создание листа в котором позиции выбраных элементов отображаются числами, а остальные null\n                    checkedItems = sprGestureDialogList.mapIndexedNotNull { index, item ->\n                        if (item.check) item.gesture.sprGestureId else null\n                    }.toMutableList()\n                    Log.d(\"DialogGestureTest\", \"checkedItems: $checkedItems\")\n\n                    gesturesRv.adapter?.notifyItemChanged(position)\n                }\n            })\n        gesturesRv.adapter = adapter\n\n\n        val cancelBtn = dialogBinding.findViewById<View>(R.id.dialogAddGesturesToCancelBtn)\n        cancelBtn.setOnClickListener {\n            myDialog.dismiss()\n        }\n\n        val saveBtn = dialogBinding.findViewById<View>(R.id.dialogAddGesturesToSaveBtn)\n        saveBtn.setOnClickListener {\n\n            myDialog.dismiss()\n\n            val listBindingGesture: MutableList<Pair<Int, Int>> = checkedItems.map { item ->\n                // Ищем пару с first == item\n                val existingPair = bindingGestureList.find { it.first == item }\n                // Если нашли, используем существующее second, иначе 0\n                if (existingPair != null) {\n                    Pair(item, existingPair.second)\n                } else {\n                    Pair(item, 0)\n                }\n            }.toMutableList()\n\n\n            onSaveClickDialog.invoke(listBindingGesture)\n        }\n    }\n    open fun showGestureSettings(deviceAddress: Int, parameterID: Int, gestureID: Int) {\n        val intent = Intent(context, UBI4GripperScreenWithEncodersActivity::class.java)\n        intent.putExtra(DEVICE_ID_IN_SYSTEM_UBI4, deviceAddress)\n        intent.putExtra(PARAMETER_ID_IN_SYSTEM_UBI4, parameterID)\n        intent.putExtra(GESTURE_ID_IN_SYSTEM_UBI4, gestureID)\n        startActivity(intent)\n    }\n    open fun requestGestureSettings(deviceAddress: Int, parameterID: Int, gestureID: Int) {\n        if (!isAdded) { return }\n        transmitter().bleCommandWithQueue(BLECommands.requestGestureInfo(deviceAddress, parameterID, gestureID), MAIN_CHANNEL, WRITE) {}\n    }\n    open fun showCustomGesturesDialog(onSaveDotsClick: (Pair<Int, Int>) -> Unit, bindingItem: Pair<Int, Int>) {\n        val dialogBinding = layoutInflater.inflate(R.layout.ubi4_dialog_gestures_add_to_spr_screen, null)\n        val myDialog = Dialog(requireContext())\n        val gesturesRv = dialogBinding.findViewById<RecyclerView>(R.id.dialogAddGesturesRv)\n        val linearLayoutManager = LinearLayoutManager(context)\n\n        myDialog.setContentView(dialogBinding)\n        myDialog.setCancelable(false)\n        myDialog.window?.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))\n        myDialog.show()\n\n        val titleText = dialogBinding.findViewById<TextView>(R.id.dialogTitleBindingTv)\n        titleText.setText(R.string.assign_gesture)\n\n        val collectionGestureDialogList: ArrayList<DialogCollectionGestureItem> = ArrayList(\n            collectionGesturesProvider.getCollectionGestures().map { gesture ->\n                DialogCollectionGestureItem(\n                    gesture = gesture,\n                    check = (gesture.gestureId == bindingItem.second)\n                )\n            }\n        )\n\n        var selectedGesturePosition = collectionGestureDialogList.indexOfFirst { it.check }\n        var selectedGestureId = bindingItem.second\n        Log.d(\"DialogGestureTest\", \"selectedGesturePosition $selectedGesturePosition\")\n        linearLayoutManager.orientation = LinearLayoutManager.VERTICAL\n        gesturesRv.layoutManager = linearLayoutManager\n\n        val adapter = GesturesCheckAdapter(\n            collectionGestureDialogList,\n            object : OnCheckGestureListener {\n                override fun onGestureClicked(\n                    clickedPosition: Int,\n                    dialogGesture: DialogCollectionGestureItem\n                ) {\n                    if (selectedGesturePosition == clickedPosition) {\n                        // снимаем выделение\n\n                        collectionGestureDialogList[clickedPosition] = collectionGestureDialogList[clickedPosition].copy(\n                            check = false\n                        )\n                        selectedGesturePosition = -1\n                        selectedGestureId = -1\n                        gesturesRv.adapter?.notifyItemChanged(clickedPosition)\n                        Log.d(\"DialogGestureTest\", \"selectedGesturePosition $selectedGesturePosition\")\n\n                        return\n                    }\n                    if (selectedGesturePosition != -1) {\n                        collectionGestureDialogList[selectedGesturePosition] =\n                            collectionGestureDialogList[selectedGesturePosition].copy(check = false)\n                        gesturesRv.adapter?.notifyItemChanged(selectedGesturePosition)\n\n                    }\n\n                    // Устанавливаем текущий жест как выбранный\n                    selectedGesturePosition = clickedPosition\n                    selectedGestureId = dialogGesture.gesture.gestureId\n                    collectionGestureDialogList[clickedPosition] =\n                        collectionGestureDialogList[clickedPosition].copy(check = true)\n                    gesturesRv.adapter?.notifyItemChanged(clickedPosition)\n                    Log.d(\"DialogGestureTest\", \"selectedGestureId $selectedGestureId\")\n\n                }\n\n            }\n        )\n        gesturesRv.adapter = adapter\n\n        val cancelBtn = dialogBinding.findViewById<View>(R.id.dialogAddGesturesToCancelBtn)\n        cancelBtn.setOnClickListener {\n            myDialog.dismiss()\n        }\n\n        val saveBtn = dialogBinding.findViewById<View>(R.id.dialogAddGesturesToSaveBtn)\n        saveBtn.setOnClickListener {\n            val sendBindingItem = if (selectedGestureId != -1) { Pair(bindingItem.first, selectedGestureId)\n            } else { Pair(bindingItem.first, 0) }\n\n            onSaveDotsClick.invoke(sendBindingItem)\n            myDialog.dismiss()\n        }\n    }\n    open fun sendBLEActiveGesture(deviceAddress: Int, parameterID: Int, activeGesture: Int) {\n        if (!isAdded) { return }\n        transmitter().bleCommandWithQueue(BLECommands.sendActiveGesture(deviceAddress, parameterID, activeGesture), MAIN_CHANNEL, WRITE){}\n    }\n    open fun requestActiveGesture(deviceAddress: Int, parameterID: Int) {\n        if (!isAdded) {return}\n        transmitter().bleCommandWithQueue(BLECommands.requestActiveGesture(deviceAddress, parameterID), MAIN_CHANNEL, WRITE){}\n    }\n    open fun sendBLEBindingGroup(deviceAddress: Int, parameterID: Int, bindingGestureGroup: BindingGestureGroup) {\n        if (!isAdded) { return }\n        transmitter().bleCommandWithQueue(BLECommands.sendBindingGroupInfo (deviceAddress, parameterID, bindingGestureGroup), MAIN_CHANNEL, WRITE){}\n    }\n    open fun requestBindingGroup(deviceAddress: Int, parameterID: Int) {\n        if (!isAdded) { return }\n        transmitter().bleCommandWithQueue(BLECommands.requestBindingGroup(deviceAddress, parameterID), MAIN_CHANNEL, WRITE){}\n    }\n    @SuppressLint(\"MissingInflatedId\")\n    open fun showConfirmTrainingDialog(confirmClick: () -> Unit) {\n        main?.showToast(\"Виджет отображается вне своего экрана\")\n    }\n    open fun showAddGestureToRotationGroupDialog(onSaveDialogClick: ((selectedGestures: ArrayList<Gesture>)->Unit)) {\n        main?.showToast(\"Виджет отображается вне своего экрана\")\n    }\n    open fun sendBLERotationGroup (deviceAddress: Int, parameterID: Int) {\n        main?.showToast(\"Виджет отображается вне своего экрана\")\n    }\n    private fun requestRotationGroup(deviceAddress: Int, parameterID: Int) {\n        if (!isAdded) return\n        transmitter().bleCommandWithQueue(BLECommands.requestRotationGroup(deviceAddress, parameterID), MAIN_CHANNEL, WRITE){}\n\n    }\n    open fun refreshWidgetsList() {\n        onDestroyParentCallbacks.forEach { it.invoke() }\n        onDestroyParentCallbacks.clear()\n        listWidgets.clear()\n        transmitter().bleCommandWithQueue(BLECommands.requestInicializeInformation(), MAIN_CHANNEL, WRITE){}\n    }\n\n    open fun showConfirmLoadingDialog(onConfirm: () -> Unit) {\n        if (loadingCurrentDialog != null && loadingCurrentDialog?.isShowing == true) {\n            return\n        }\n        closeCurrentDialog()\n        val dialogFileBinding = layoutInflater.inflate(R.layout.ubi4_dialog_confirm_loading, null)\n        val myDialog = Dialog(requireContext())\n        myDialog.setContentView(dialogFileBinding)\n        myDialog.setCancelable(false)\n        myDialog.window!!.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))\n        loadingCurrentDialog = myDialog\n        myDialog.show()\n\n        val confirmBtn = dialogFileBinding.findViewById<View>(R.id.ubi4DialogConfirmLoadingBtn)\n        confirmBtn.setOnClickListener {\n            closeCurrentDialog()\n            onConfirm()\n        }\n        val cancelBtn = dialogFileBinding.findViewById<View>(R.id.ubi4DialogLoadingCancelBtn)\n        cancelBtn.setOnClickListener {\n            myDialog.dismiss()\n        }\n    }\n    open fun showFilesDialog(addressDevice: Int, parameterID: Int) {\n        main?.showToast(\"Виджет отображается вне своего экрана\")\n    }\n    @SuppressLint(\"InflateParams\", \"StringFormatInvalid\", \"SetTextI18n\")\n    open fun showDeleteGestureFromRotationGroupDialog(resultCb: ((result: Int)->Unit), gestureName: String) {\n        main?.showToast(\"Виджет отображается вне своего экрана\")\n    }\n\n\n    private fun sendSwitcherState(addressDevice: Int, parameterID: Int, switchState: Boolean) {\n        Log.d(\"sendSwitcherState\", \"addressDevice: $addressDevice, parameterID: $parameterID, switchState: $switchState\")\n        transmitter().bleCommandWithQueue(BLECommands.sendSwitcherCommand(addressDevice, parameterID, switchState), MAIN_CHANNEL, WRITE){}\n    }\n    private fun sendSliderProgress(addressDevice: Int, parameterID: Int, progress: ArrayList<Int>) {\n        Log.d(\"sendSliderProgress\", \"addressDevice: $addressDevice, parameterID: $parameterID, progress: $progress\")\n        transmitter().bleCommandWithQueue(BLECommands.sendSliderCommand(addressDevice, parameterID, progress), MAIN_CHANNEL, WRITE){}\n    }\n    open fun clearSwitcherCache() {\n        Log.d(\"clearSwitcherCache\", \"clearSwitcherCache run\")\n        onClearSwitcherCache.invoke()\n    }\n\n    //Others fun\n    private fun loadGestureNameList() {\n        val macKey = navigator().getString(PreferenceKeysUBI4.LAST_CONNECTION_MAC_UBI4)\n        gestureNameList.clear()\n        for (i in 0 until PreferenceKeysUBI4.NUM_GESTURES) {\n            System.err.println(\"loadGestureNameList: \" + PreferenceKeysUBI4.SELECT_GESTURE_SETTINGS_NUM + macKey + i)\n            gestureNameList.add(\n                navigator().getString(PreferenceKeysUBI4.SELECT_GESTURE_SETTINGS_NUM + macKey + i)\n            )\n        }\n    }\n    open fun closeCurrentDialog() {\n        loadingCurrentDialog?.dismiss()\n        loadingCurrentDialog = null\n    }\n    open suspend fun sendFileInChunks(byteArray: ByteArray, name: String, addressDevice: Int, parameterID: Int) {}\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/bailout/stickk/ubi4/ui/fragments/base/BaseWidgetsFragment.kt b/app/src/main/java/com/bailout/stickk/ubi4/ui/fragments/base/BaseWidgetsFragment.kt
--- a/app/src/main/java/com/bailout/stickk/ubi4/ui/fragments/base/BaseWidgetsFragment.kt	(revision 1a228a9dd5ccade415abcd1272be584eef75853c)
+++ b/app/src/main/java/com/bailout/stickk/ubi4/ui/fragments/base/BaseWidgetsFragment.kt	(date 1748357856158)
@@ -199,11 +199,11 @@
 //    open fun onPlotReady(num: Int) {}
     open fun oneButtonPressed(addressDevice: Int, parameterID: Int, command: Int) {
         transmitter().bleCommand(BLECommands.sendOneButtonCommand(addressDevice, parameterID, command), MAIN_CHANNEL, WRITE)
-        Log.d("TestButton", "oneButtonPressed run")
+        Log.d("TestButton", "oneButtonPressed run $addressDevice $parameterID $command")
     }
     open fun oneButtonReleased(addressDevice: Int, parameterID: Int, command: Int) {
         transmitter().bleCommand(BLECommands.sendOneButtonCommand(addressDevice, parameterID, command), MAIN_CHANNEL, WRITE)
-        Log.d("TestButton", "oneButtonReleased run")
+        Log.d("TestButton", "oneButtonPressed run $addressDevice $parameterID $command")
 
     }
     open fun showControlGesturesDialog(onSaveClickDialog: (MutableList<Pair<Int, Int>>) -> Unit, bindingGestureList:  List<Pair<Int, Int>>) {
